<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>

<link rel="stylesheet" href="css/style.css">
</head>
<body>

        <nav id="navbar">
                <header>JS Documentation</header>
                <ul> 
                    <!-- href="Name_name-->
                  <a class="nav-link" href="#Html5" rel="internal"><li>HTML5</li></a>
                  <a class="nav-link" href="#CSS3" rel="internal"><li>CSS3</li></a>
                  <a class="nav-link" href="#Javascript" rel="internal"><li>Javascript Fundamentals</li></a>
                  <a class="nav-link" href="#ECMAScript6" rel="internal"><li>ECMAScript6 +</li></a>
                  <a class="nav-link" href="#jQuery" rel="internal"><li>jQuery</li></a>
                  <a class="nav-link" href="#OOP" rel="internal"><li>OOP</li></a>
                  <a class="nav-link" href="#DevTools" rel="internal"><li>Chrome DevTools</li></a>
                  <a class="nav-link" href="#DOM" rel="internal"><li>DOM</li></a>
                  <a class="nav-link" href="#UX" rel="internal"><li>UX</li></a>
                  <a class="nav-link" href="#Sass" rel="internal"><li>Sass/SCSS</li></a>
<!--split-->
                  
                  <a class="nav-link" href="#Terminal" rel="internal"><li>Terminal Commands</li></a>
                  <a class="nav-link" href="#Node" rel="internal"><li>Node</li></a>
                  <a class="nav-link" href="#Http" rel="internal"><li>HTTP</li></a>
                  <a class="nav-link" href="#API" rel="internal"><li>API Basics</li></a>
                  <a class="nav-link" href="#REST" rel="internal"><li>REST</li></a>
                  <a class="nav-link" href="#SDP" rel="internal"><li>Software Design Principles</li></a>
                  <a class="nav-link" href="#Ajax" rel="internal"><li>Ajax</li></a>
                  <a class="nav-link" href="#Cloud" rel="internal"><li>Cloud Basics</li></a>
                  <a class="nav-link" href="#Sessions" rel="internal"><li>Sessions & Cookies</li></a>
                  <a class="nav-link" href="#Git" rel="internal"><li>Git</li></a>
                  <a class="nav-link" href="#Express" rel="internal"><li>ExpressJS</li></a>

                  <a class="nav-link" href="#Reference" rel="internal"><li>Reference</li></a>
                </ul>
              </nav>
              <main id="main-doc">

                <section class="main-section" id="Html5">                
                    <header>HTML5</header>
                  <article>  
                   
                  </article>
                  </section>

                <section class="main-section" id="CSS3">
                  <header>CSS3</header>
                  <article>
                 
                  </article>
                  </section>            
                
                  <section class="main-section" id="Javascript">
                  <header>Javascript Fundamentals</header>
                  <article>

                      <h2>JS Editions: </h2>
                      <li> 5th Edition (2009) </li>
                      <li> 6th Edition - ECMAScript 2015 </li>
                      <li> 7th Edition - ECMAScript 2016 </li>
                      <li> 8th Edition - ECMAScript 2017 </li>
                      <li> 9th Edition - ECMAScript 2018 </li>
                      <li> ES.Next - Dynamic name referring to whatever the next version is at the time of writing. <br />
                      (ESNext feautres are actually referred to as proposals since they haven't happened yet.)

                      <h2>CALLBACK FUNCTIONS:</h2>
                    <b>Callback</b> - A function which is:
                          <li>Passed as an ARGUMENT to another function, and </li>
                          <li>Is invoked after some kind of event (so callback is the child function of a parent almost but not bound to scope) </li>
                          
                        <p>  A callback is a function you provide to another piece of code, allowing it to be called by that code. To "call back" means to pass a function to other function or other 			  code. So it's passed into another function as an argument, which is then invoked inside the "outer function" to complete something. And once a callback function's parent function completes, the function passed as an argument is then called.</p>
                       <p> Callback functions are also called higher-order functions.</p>
                          
                          
                        Example of a callback:
			<code>
                          XMLHttpRequest.onreadystatechange = callback;
			</code>
                         This is just a function passed almost like the parameters for another function, that is then also called when that "parent function" is triggered. So you run the parent one and it calls back whatever then gets filled in.
                          


                         <h2>CROSS-BROWSER ISSUES:</h2>

                         <p>JS in different browsers:</p>
                         <p>This originates in the 90s when there were IE and Netscape - Netscape had JS and IE had Jscript and VBScript
                         Things like jQuery were created to abstract away differences in brower implementations</p>
                         
                         <p>JS compatibility issues happen when:</p>
                         <li>Bad code in regards to feature detection browser sniffing etc blocks browsers from rnnng otherwise fine code</li>
                         <li>When new features are used in code but not supported in older browsers.</li>
                         
                         
                         <h2>CURRYING:</h2>

                         <p>
                        <b>Currying </b>provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument.
                         An example would be situations where some analytical techniques can only be applied to functions with a single argument.
                         In theoretical work it provides a way to study functions with multiple arguments in a simpler theoretical model that provides only one argument.</p>
                         
                         <p>Currying can equal returning a bunch of things or also like how php template tags let you "repeat" things easier than with html across pages.</p>
                          



                     
                         <h2>CLOSURES:</h2>


                         <p><b>Closures</b> are important because: <br />
                         1. A scope is at the function level, not the block level<br />
                         2. Much of what you do in hs is async / event-driven<br />
                         3. They make event-driven code a lot easier to write
                         <p>
                         A closure is an inner function that has access to the outer (enclosing) function's variables and parameters.
                         The inner function then has access to the outer function's variables and parameters.
                         Even after the outer function has returned, the inner function still has access to the outer function's variables.
                         So, you can call the inner function later in your program.
                         </p>
                         <p>
                         A closure is a function that returns a function - so it's the whole thing and not just the inner function being the closure.
                         The function that is returned (the inner function) is created inside the called function (the outer).
                         Due to the scoping rules we’ve seen, the inner has access to the variables and arguments of the outer. <br /><br />
                         Functions created in a particular scope retain access to vars in the scope even if they are called outside of it, because there's 1. create and 2. call with functions.<br /><br />
                         Example of a closure:
                         </p>
                         <code>
                         function one(a, b){
                           function two(){
                           return "foo";
                           }
                           var variable;
                           return variable;
                         }
                         two();
                         </code>
                         <p>
                         So, even though two is called outside of the function one because it's created inside of one, it has access to one's scope.<br />
                         two() can access one's params (a and b), and var variable / the return statement since it's in one's body and therefore scope.
                         </p>

                         <h2>Debugging:</h2>
                         <p>Can be done via:</p>
                         
                         <li>Console in browser</li>
                         <li>JS Validator AKA <b>linting</b> - Checks to make sure code is valid and follows syntax of language (LINTING)</li>
                         <li>JS Debugging app <a href="http://www.hacksrus.com/~ginda/venkman/" target="blank">hacksrus.com/~ginda/venkman/</a></li><br />
                         
                         <p>Linting can go through source code and find:</p>
                         <li>Non-adherence to coding standards</li>
                         <li>Pinpointing possible logical errors in program</li>
                         
                         <p>
                        <b>ESLint</b> -
                         Javascript linter that requires node.js<br />
                         <b>JSHint</b> - 
                         Online linter<br />
                         </p>
                         
                         <h2>FEATURE DETECTION:</h2>

                         <p><b>Feature detection</b> - Working out whether a browser supports a certain block of code, and running different code dependent on whether it does or doesn't so a browser can always provide a working experience rather than crashing/erroring in some browsers.<br />
                         
                         An example would be testing flexbox support in a browser. <br />
                                                 
                         Modernizr is the industry standard for feature detection tests. Feature detection is made easy in CSS with the @supports @ rule.
                         </p>
                         <p>
                         Do not confuse feature detection with <b>browser sniffing</b>: <br /><br />
                         feature detection = good<br />
                         browser sniffing = bad<br /><br />
                         
                         Browser sniffing is bad because it's an error prone process - the only real use is fixing a bug for a very specific version of a particular browser.
                         </p>
                         
                         Example of feature detection:
                         <code>
                         if("geolocation" in navigator){
                           navigator.geolocation.getCurrentPosition(etc…)
                           //show location on a map
                         } else{
                           //give user choice of static maps instead
                         };
                         </code>
                         



                        <h2>HOISTING:</h2>

                        <p>Variables declared w/ var are “hoisted” to “top” scope as in they can’t be declared twice I think. <br />
                        Basically why when you have an if else statement, you can’t declare the same variable twice using “var” or it will get an “___ already defined” error. <br />
                        Technically you could have an if/else statement referencing “action” and define “var action” after them.<br />
                        </p>
                         
<h2>I.I.F.E.:</h2>

<b>Immediately Invoked Function Expression</b> - Allows you to control variable scope - variables inside an IIFE aren’t available outside it.

                       <h2>IMAGE MAPS:</h2>

You can make image maps in Javascript: <a href="https://www.tutorialspoint.com/javascript/javascript_image_map.htm">https://www.tutorialspoint.com/javascript/javascript_image_map.htm</a> <br />
An image map = clickable areas. You can also define coordinates.

<h2>METHODS:</h2>

List of JS methods:



<h2>NULL VS. UNDEFINED VS. NaN:</h2>
<p>
Null = Can be assigned to a variable as a representation of no value. <br />
Undefined = A variable that has not been assigned a value. <br /> <br />

typeof null = object<br />

typeof undefined = it's already a type - undefined<br /><br />

So, undefined is a type itself, while null is an object you can interact with ("empty").<br />
So null can be some empty placeholder thing, ex.: </p>

<code>

null + 3
= 3

</code>
<br />
Whereas with undefined:
<code>
undefined + 3
= undefined or NaN
</code>
<p>
If arithmetic makes no sense, JS yields special Numbers:</p>
<code>
Infinity or NaN(Not a Number).
console.log(5 / 0);
//->Infinity
</code>


<h2>PROPERTIES VS. METHODS:</h2>

<li>Data is represented as PROPERTIES of the object, and
<li>Behavior is represented as the methods</li>

<p>
Method: <br />
In OOP, it's a procedure associated with a. A message (almost like an HTTP header) and b. an Object.
</p>
<p>
That's what an object is and that's what object oriented is: everything including DOM elements has their a. properties (if available) and b. methods (if available). So all the object.thing1.thing2 can be applied to everything.
</p>
<p>
Ex.: A Window object would have methods such as open and close. <br /> 
That's what it means by procedural is the method is a procedure to be carried out as a message to the object to enact something, while its state is a property.
</p>
<p>
Open and close i.e. procedures i.e. imperatives are methods or things you can perform on/with the object.
State or value in an array or key-value pair shit or even like location are properties.
</p><p>
Methods are like miniature algorithms, while properties are characteristics.
Methods allow you to interact with the properties of an object.
This is also what people mean when they say encapsulation.
</p><p>
Methods are actions that can be performed on objects.
The name:values pairs (in JavaScript objects) are called properties.
</p>


<h2>PROTOTYPES:</h2>
<p>
Javascript is multi-paradigm:  <br />
1. OOP with prototypal inheritance <br />
2. Functional programming <br />
3. Imperative/procedural programming <br />
</p>
<p>
Every JS object has a prototype. The prototype is also an object. All JS objects inherit their properties and methods from their prototype. The prototype pattern creates new objects, but rather than creating non-initialized objects, it returns objects that are initialized w the values copied from the prototype object.
</p>

So there's: <br /><br />

1. The prototype (sample)<br />
2. The clone<br />
3. The creation of that clone<br /><br />
Ex.: <br />
1. function CustomerPrototype(proto){} - //the prototype <br />
2. function Customer(first, last, something){} - //The cloned objects being created <br />
3. function run(){} - //creates new object by asking prototype to clone itself <br />
<br />
<h3>Rules:</h3>
<li>Objects created with new Object() inherit from a prototype called Object.prototype.</li>
<li>Object.protoype is at the top of the chain - so all objects inherit from this.</li>
<li>When you ask for a property of an object, JS looks for that property - if it doesnt find it, it follows the prototype chain until it finds the property, or returns undefined.</li>

<h3>Terms:</h3>

<b>new</b> keyword - <br />
new constructor[(arguments)]<br />
<b>constructor</b> - Special method for creating an object within a class.<br />
So JS DOES have classes but they were only introduced in ECMA 2015 ( so constructors are kind of new with JS)<br />
class-based - constructors & factory method pattern<br />
prototypal - prototype design pattern. Each instance of an object created from the prototype is just a copy.<br />

<h3>Classical vs. Prototypal:</h3>

<b>Classical inheritance</b> - Aka class inheritance "instances" inherit from classes, like a blueprint (PHP). <br />
These are usually instantiated via constructor functions using the new keyword. (PHP) <br />
Class inheritance may or may not use the "class" keyword. <br /><br />

<b>Prototypal inheritance</b> - Aka "instances" inherit directly from other objects aka "prototypes".<br />
They're usually instantiated via "factory functions" or ex. object.create().<br />
Prototypal inheritance is simpler and more flexible than class inheritance.<br />
Prototypal inheritance = objects WITHOUT CLASSES, OLOO. <br />

<h2>PURE FUNCTIONS</h2>

A function where the return value is only determined by its input values w/o side-effects. <br />
Ex.: math.cos(x). Computing this does not change "x" - doesn't ask for input or change state. <br />
So pure = stateless for the most part.

<h2>RECURSION</h2>
  <p>
  <b>Recursion</b> - A function invoking (calling) itself again and again until it reaches the final return condition at which point it returns the final value.<br /><br />
  Each time the function is called, a new local scope is created.
  
  </p>



  <h2>TYPES</h2>

  <h3>There are 7 total data types:</h3>
  
  Primitive types: <br />
  <li>Boolean</li>
  <li>Null</li>
  <li>Undefined</li>
  <li>Number</li>
  <li>String</li>
  <li>Symbol(new in ES6)</li>
  <br />
  
  Non-primitive types: <br />
  <li>Object</li><br />
  
  All types except the non-primitive type, object, define immutable values, incapable of being changed.
  <br /><br />
  Function = primitive type<br />
  Object = complex type<br /><br />
  
  Every "thing" in JS - including primitive data types and other things - Ex.: <br /> 
  <li>Date Object</li>
  <li>String Object</li>
  <li>Number Object</li>
  <li>Math Object</li>
  <li>Array Object</li>
  <li>Boolean Object</li>
  <li>Error Object</li>
  <li>RegExp Object</li>
  <br />
  These are all OBJECTS - as in they have specific PROPERTIES and then METHODS. So Math is an object as well.
  <br />
  <h3>Terms:</h3>
  
  Polymorphism - A type whose operations can be applied to values of some other type or types. (ex. int and variables) <br /><br />
  
  Subtypes -Ex. cat is a subtype of animal. So, an expression of type cat can be used anywhere that type animal is used. <br /><br />
  
  Type Theory - When with math they write f: X —> Y, X is the old type, Y is the new type being built from the old, and the arrod is a type constructor that i guess designates this.



  <h2>RETURN STATEMENTS</h2>
  <p>
  <b>Return</b> - a and b are a function’s parameters, and the value it returns is signified by the return keyword. 
  <li>The return keyword also stops execution of the code in the function; nothing after it will be run.</li>
  <li>Functions without a return, aka “returning nothing”, will end up being “undefined”. Every function is going to return “Undefined” UNLESS you give it a return value. </li>
  <li>A function's return value can be passed to another function as a parameter.</li>
  </p>
  


<h2>SELECTORS:</h2> 

Use a <b>selector</b> to grab an element, ex.:
<code>
var numOne = document.getElementById(“num-one”);</code>

<h2>SIDE EFFECTS:</h2>
<p>
<b>side-effects</b> - Any app state change that is observable (aka opposite of pure functions). Side effects are avoided in functional programming. <br /> <br />
Ex.: Writing to a file, triggering any external process, logging to the console.
</p>

<h2>STATE:</h2>
<p>
<b>State</b> - Information about something held in memory. The set values that something's attributes have at any given moment (things saved to memory).<br /><br />
Ex.: 10, or "HELLO"= By itself is stateless - does not represent any state. (aka pure values)
<br />
There's a state when these "pure values" are associated to some kind of entities, for ex. objects. <br /><br />
Ex.:<br />
var car = ("color", "blue"); = properties of "car".<br /> Since car has properties it has a state.
It's associated to an "entity" (i.e. class/object I think), but ALSO to a point in time.
So if today car = color, blue but tomorrow it's color, black, then black is the new state of that car object.<br /><br />Properties = states.<br />
When the properties change, the states change.<br /><br />


<b>Shared state</b> - aka shared mutability. Can be bad because code isn't like containerized or separated or whatever, so it can be a mess.

</p>


<h2>THIS OPERATOR:</h2>

Ex.:<br /><br />

"John is running fast because <b>he</b> is trying to catch the train".<br /><br />

The this operator acts like the pronoun "he" - so we don't have to say "John is running fast because John is trying to catch the train".
<br /><br />

Ex.:

<code>
var person = {
	firstName: "Bob",
	lastName: "Logg",
	function fullName(){
	console.log(this.firstName + this.lastName);
	console.log(person.firstName + person.Lastname);
	}
}</code>

In this instance, this.firstName is the same as saying person.FirstName, so it just lets you	reference it without being redundant.

This is used because there could be a global var w the same name as the one you're interacting with (ex. global person and var person).
<br /><br />
Ex.:
<code>
$("button").click(function (event){
	console.log($ (this).prop ("name"));
this will have a val of ($("button"))
});</code>

So this can be used in syntax where you need to access an function's props within the function itself ex.:
<code>
function showFullName(){
	console.log(this.firstName + this.LastName);
}</code>



</article>

                  </section>

                <section class="main-section" id="ECMAScript6">
                  <header>ECMAScript6 +</header>
                  <article> 
                  </article>

                  </section>

                <section class="main-section" id="jQuery">
                  <header>jQuery</header>
                  <article> 
                    </article>
                 
                  </section>

                <section class="main-section" id="OOP">
                  <header>OOP</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="DevTools">
                  <header>Chrome DevTools</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="DOM">
                  <header>DOM</header>
                  <article>
                  <!--Event listener - Attached to element to listen for interaction (mouseclick etc)-->
                  </article>
                  </section>

                <section class="main-section" id="UX">
                  <header>UX</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="Sass">
                  <header>Sass/SCSS</header>
                  <article>
                  </article>
                  </section>                  
<!--split-->

                <section class="main-section" id="Terminal">
                  <header>Terminal Commands</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="Node">
                  <header>Node</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="Http">
                  <header>HTTP</header>
                  <article>
                  </article>
                  </section>

                <section class="main-section" id="API">
                  <header>API Basics</header>
                  <article> 
                  </article>
                  </section>

                <section class="main-section" id="REST">
                  <header>REST</header>
                  <article> 
                  </article>
                  </section>

                <section class="main-section" id="SDP">
                  <header>Software Design Principles</header>
                  <article> 
                  </article>
                  </section>

                <section class="main-section" id="Ajax">
                  <header>Ajax</header>
                  <article> 

                    <!--WHAT AJAX ACTUALLY IS-


You have BOTH the thing being changed, i.e. the "starting code", IN the code, AND
You have the CHANGE TO BE IMPLEMENTED, which is updated by the server depending on params or whatever, ALSO IN THE CODE

So STATES = XMLHttpRequest.onreadystatechange - You have the BEGINNING and the STARTING STATE! and it's updated/filled in by the server depending on the provided shit

AJAX - 
Update a webpage w/o reloading page
-Request data from server AFTER PAGE HAS LOADED		(OPP DI)
-RECEIVE data from server as well					(LIKE DI)
-SEND data to a server							

AJAX *IS* ASYNC
(Asynchronous Javascript And XML lol godammt) - Not really XML anymore might as well be called AJAJ lol

XMLHttpRequest —> AJAX

1. An event occurs in a webpage (page load, button is clicked - some shit at compile to runtime)
2. An XMLHttpRequest OBJECT is created by JS
3. That OBJECT sends a request to a web server
4. The server processes the request
5. Server sends back response to webpage
6. Response is read (parsed lol) by JS
7. Proper action like page update/section/content update is performed by the JS


ALL MODERN BROWSERS SUPPORT THE XMLHttpRequest OBJECT
SO BASICALLY UPDATE PARTS OF PAGE W / O PAGE RELOAD

HOWEVER, DRAWBACK OF AJAX:
-Can't really make cross-domain requests - the page you're making the request from and the resource have to be on the same server

CROSS-DOMAIN JS CALLS - 

Ajax = basically a general term for MAKING YOUR WEBPAGE DO *DYNAMIC* STUFF ON THE SERVER (ex. make a new post, remove a user, etc.)

Javascript alone is clien-side - can't affect the DB directly. Needs a TECHNIQUE like AJAX to CAUSE AN ACTUAL EFFECT ON THE SERVER.

Normal JS functionality only becomes AJAX WHEN A REMOTE CALL IS EVOLVED

AJAX has two sides
-The JS which MAKES the request
-The dynamic page, which does something (changes like a controller updating the model), and returns a RESPONSE

AJAX = REQUEST —> RESPONSE

The dynamic side can be done in PHP, ASP, Ruby on Rails, C++, anything running on webserver.

-->
                  </article>
                  </section>
                  
                <section class="main-section" id="Cloud">
                  <header>Cloud Basics</header>
                  <article> 
                  </article>
                  </section>         
                  
                <section class="main-section" id="Sessions">
                  <header>Sessions & Cookies</header>
                  <article> 
                  </article>
                  </section>

                <section class="main-section" id="Git">
                  <header>Git</header>
                  <article> 
                    <h2>VSCode Git Setup Steps:</h2>                      
                    <p>
                      1. Clone repo. from Github <br />
                      2. Make sure username and email are set up using git config   <br /> 
                      3. Make changes <br />
                      4. Add message and commit
                      (git commit = local) <br />
                      5. THEN push changes <br />                    
                      6. Enter gh username and password (sambgordon - Apple692) <br />                
                    </p>
                    <li> VScode can stage and commit changes at the same time.</li>

                  </article>
                  </section>
                  
                <section class="main-section" id="Express">
                  <header>ExpressJS</header>
                  <article> 
                  </article>
                  </section>                  
                  
                <!--<section class="main-section" id="blank">
                  <header>blank</header>
                  <article> 
                  </article>
                  </section>                  
                -->

                <section class="main-section" id="Reference">
                  <header>Reference</header>
                  <article>
                  </article>
                  </section>

              </main>
</body><!--
<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>

<script src="js/script.js"></script>
-->
</html>