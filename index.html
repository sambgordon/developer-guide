<!DOCTYPE html>
<html lang="en">
<head>
  
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
  <link rel="stylesheet" href="css/style.css">
  </head>
<body>
  <nav id="navbar">
      <header id="header-main">Developer Guide {Front-end} <br />Page 1     
        </header>
        <ul> 
        <!--<div class="topelement"></div>-->
         
        <a class="nav-link" href="#HTML5" rel="internal"><li class="lightgreen ">HTML5</li>
          </a>

        <a class="nav-link" href="#DOM" rel="internal"><li class="lightgreen">DOM Basics
          </li></a>
        <!--<div class="topelement"></div>-->
        <a class="nav-link" href="#CSS3" rel="internal"></a><li class="collapsible lightblue">CSS3</li>
          <div class="content darkblue">
          <a class="nav-link sub "href="#cssBox" rel="internal">Box Model</a>
          <a class="nav-link sub "href="#cssVar" rel="internal">CSS Variables</a>
          <a class="nav-link sub "href="#cssMedia" rel="internal">Media Queries</a> 
          <a class="nav-link sub "href="#cssSelect" rel="internal">Selectors</a> 
          <a class="nav-link sub "href="#cssMeasure" rel="internal">Measurements</a> 
          <a class="nav-link sub "href="#cssKey" rel="internal">Keyframes</a> 
          <a class="nav-link sub "href="#cssGradient" rel="internal">Gradients</a> 
          <a class="nav-link sub "href="#cssSVG" rel="internal">SVG</a> 
          <a class="nav-link sub "href="#cssGrid" rel="internal">CSS Grid</a> 
          <a class="nav-link sub "href="#cssVend" rel="internal">Vendor prefixes</a> 
          <a class="nav-link subClear "href="#cssAnim" rel="internal">Animations</a>
          <a class="nav-link sub "href="#cssDisadvantage" rel="internal">CSS Disadvantages</a> 
          <a class="nav-link sub "href="#cssTips" rel="internal">Tips</a> 
          <a class="nav-link subClear "href="#cssLinks" rel="internal">Links</a> 
          </div>
        
        <a class="nav-link" href="#Bootstrap" rel="internal"><li class="lightblue">Bootstrap</li></a>
        <a class="nav-link" href="#Design" rel="internal"><li class="lightblue">Design Basics</li></a>      
        <a class="nav-link " href="#Sass" rel="internal"><li class="lightblue">SASS/SCSS</li></a>           
        <!--<div class="topelement"></div>-->
        <a class="nav-link" href="#Javascript" rel="internal"></a><li class="collapsible lightorange">
          Javascript Fundamentals</li>
          <div class="content">

          <a class="nav-link sub "href="#jsCallback" rel="internal">Callbacks</a> 
          <a class="nav-link sub "href="#jsClosure" rel="internal">Closures</a> 
          <a class="nav-link sub "href="#jsCross" rel="internal">Cross-Browser</a> 
          <a class="nav-link sub "href="#jsCurry" rel="internal">Currying</a> 
          <a class="nav-link sub "href="#jsDebug" rel="internal">Debugging</a>
          <a class="nav-link sub "href="#jsEditions" rel="internal">Editions</a> 
          <a class="nav-link sub "href="#jsFeature" rel="internal">Feature Detection</a> 
          <a class="nav-link sub "href="#jsFetch" rel="internal">Fetch API</a> 
          <a class="nav-link sub "href="#jsGet" rel="internal">Get and Set</a>          
          <a class="nav-link sub "href="#jsHoist" rel="internal">Hoisting</a> 
          <a class="nav-link sub "href="#jsIIFE" rel="internal">I.I.F.E.</a> 
          <a class="nav-link sub "href="#jsImage" rel="internal">Image Maps</a> 
          <a class="nav-link sub "href="#jsNull" rel="internal">Null</a> 
          <a class="nav-link sub "href="#jsPropVs" rel="internal">Properties Vs. Methods</a> 
          <a class="nav-link sub "href="#jsPrototype" rel="internal">Prototypes</a> 
          <a class="nav-link sub "href="#jsPrototypalVs" rel="internal">Prototypal Vs. Classical</a> 
          <a class="nav-link sub "href="#jsPure" rel="internal">Pure</a> 
          <a class="nav-link sub "href="#jsRecursion" rel="internal">Recursion</a> 
          <a class="nav-link sub "href="#jsRegex" rel="internal">Regex</a> 
          <a class="nav-link sub "href="#jsReturn" rel="internal">Return</a> 
          <a class="nav-link sub "href="#jsScope" rel="internal">Scope</a> 
          <a class="nav-link sub "href="#jsSelectors" rel="internal">Selectors</a> 
          <a class="nav-link sub "href="#jsSide" rel="internal">Side Effects</a> 
          <a class="nav-link sub "href="#jsState" rel="internal">State</a> 
          <a class="nav-link sub "href="#jsThis" rel="internal">This</a>            
          <a class="nav-link sub "href="#jsTypes" rel="internal">Types</a>                
          <a class="nav-link subClear "href="#jsVoid" rel="internal">Void Operator</a>                                  
          </div>
      
        <a class="nav-link" href="#jsDoc" rel="internal"></a><li class="collapsible lightorange">Javascript Documentation</li>
        <div class="content">
        <a class="nav-link sub" href="#js2String" rel="internal">Strings</a>
        <a class="nav-link subClear" href="#js2Array" rel="internal">Arrays</a>
        </div>

        <a class="nav-link" href="#ECMAScript6" rel="internal"></a><li class="collapsible lightorange">ES6 (ECMAScript 2015)</li></a>
          <div class="content"> 
          <a class="nav-link sub" href="#esLetConst" rel="internal">let & const</a>  
          <a class="nav-link sub" href="#esArrow" rel="internal">Arrow Functions</a>  
          <a class="nav-link sub" href="#esParam" rel="internal">Default Parameters</a>  
          <a class="nav-link sub" href="#esFor" rel="internal">for...of Loops</a>  
          <a class="nav-link sub" href="#esSpread" rel="internal">Spread</a>  
          <a class="nav-link sub" href="#esMaps" rel="internal">Maps</a>  
          <a class="nav-link sub" href="#esSets" rel="internal">Sets</a>  
          <a class="nav-link sub" href="#esStatic" rel="internal">Static Methods</a>  
          <a class="nav-link sub" href="#esGetSet" rel="internal">Getters and Setters</a>  
          <a class="nav-link sub" href="#esDestruc" rel="internal">Destructuring</a>  
          <a class="nav-link subClear" href="#esPromise" rel="internal">Promises</a>  

              </div>


        <a class="nav-link" href="#jQuery" rel="internal"><li class="lightorange">jQuery</li></a>
        <a class="nav-link" href="#OOP" rel="internal"><li class="lightorange">OOP</li></a>
        <a class="nav-link" href="#Libraries" rel="internal"><li class="lightorange">JS Libraries</li></a>
        <a class="nav-link" href="#React" rel="internal"><li class="lightorange">React</li></a>
        <a class="nav-link" href="index-2.html" rel="external"><li class="collapsible lightorange">Page 2 &rarr;</li></a>                
        <!--<div class="topelement"></div>-->

        
      </ul>
    </nav>
  <main id="main-doc">
          <section class="main-section" id="HTML5">                
              <header>HTML5</header>
            <article>  

            </article>
            </section>

          <section class="main-section" id="DOM">
                <header>DOM Basics</header>
                <article>
    
                    <h3>Summary</h3>
                    

                    <p>


                    
                    <strong>Document Object Model</strong> - An API that has a HTML, XHTML, or XML doc represented as a tree structure <strong>wherein each node is an object</strong> representing part of the document. <br />
                    Established in 1998 by Tim Berners-Lee aka the WWWC.<br />
                    
                    Any visual changes occuring as a result may then be reflected in the display of the document.<br />
                    
                    Javascript (and something called JScript) was the first thing to let web devs create pages w client-side interactivity.<br />
                    
                    The DOM was essentially created to give devs a way to interact with the parts of an HTML doc, to modify it as well, because there wasn't one yet.<br /><br />
                    
                    So the DOM is just "the standard" and an API that must be understood in order to interact with the elements therein.<br />
    
                   When a web page is loaded, the browser creates a D O M of the page, which is an OO representation of an HTML document. <br />
    
                   Most web browsers basically use the DOM to render a doc like an HTML page. <br />
    
                   The top-most node is the Document Object - all obejects have their prototypes so programatically speaking it's safe to assume that any node in the DOM is represented as an object that has a prototype which follows some possibly arbitray prototype inheritance chain. That chain all heads to null which is the only object without its prototype.
    
     
                 
                    </p>
                    
                    <h3>DOM Levels</h3>



                    <table class="table1">
                        <tr>
                          <th class="clearRight">DOM Level</th>
                         <th class="clearLeft"></th>
                        </tr>
                        <tr>
                          <td class="columnLeft">DOM level 0 </td>
                          <td class="columnRight">Didn't actually exist formally.</td>
                        </tr>
                        <tr>
                          <td class="columnLeft">DOM level 1</td>
                          <td class="columnRight" >Finally provided a complete model for an entire HTML / XML document, including the means to change any portion of the document, via Javascript.</td>
                        </tr>
                        <tr>
                          <td class="columnLeft">DOM level 2</td>
                          <td class="columnRight">Published in late 2000. Introduced the getElementById function as well as an event model, AND support for XML namespaces, and CSS.</td>
                        </tr>
                        <tr>
                          <td class="columnLeft">DOM level 3</td>
                          <td class="columnRight">Published in 2004. Added support for XPath and Keyboard Event Handling, as well as an interface for serializing docs as XML.</td>
                        </tr>
                        <tr>
                          <td class="columnLeft">DOM level 4</td>
                          <td class="columnRight">Published in 2015 - It's a snapshot of the WHATWG living standard.</td>
                        </tr>
                      </table>


    
                <!--Event listener - Attached to element to listen for interaction (mouseclick etc)-->
                <h3>DOM Event Concepts</h3>
                <strong>Event</strong> - anything the user does to interact with the page. <br /><br />
                <strong>UI events</strong> - extends the DOM Event objects defined in the DOM.<br />
    
                <strong>Event delegation</strong> - JS event listeners fire on a DOM element AND all its descendants.<br />
                <strong>Event bubbling</strong> - inverse of delegation: events on an element will “bubble” up to parents.<br />
    
                Each available event has an <strong>event handler</strong> - a block of code, usually user-defined JS function, that will be run when the event fires.<br />
                When defining these blocks of code, it's registering an event handler.
    
                Event handler &lt;-&gt; event listener (more or less interchangeable).<br /><br />
    
    
                <h4>DOM Event Types</h4>


                <table class="table2">
                    <tr>
                      <th class="clearRight">Types</th>
                      <th class="clearMid"></th>
                      <th class="clearMid"></th>
                      <th class="clearMid"></th>
                      <th class="clearLeft"></th>                     
                    </tr>
                    <tr>
                      <td>Clipboard Events</td>
                      <td>CSS Animation Events</td>
                      <td>CSS Transition Events</td>
                      <td>Drag & Drop Events</td>
                      <td>Document events</td>
                    </tr>
                    <tr>
                      <td>DOM mutation events</td>
                      <td>Form Events</td>
                      <td>Focus Events</td>       
                      <td>Keyboard Events</td>
                      <td>Media Events</td>                     
                    </tr>
                    <tr>
                      <td>Mouse Events</td>
                      <td>Network Events</td>        
                      <td>Progress Events</td>
                      <td>Printing Events</td>
                      <td>Resource Events</td>
                    </tr>
                    <tr>
                      <td>Session History Events</td>
                      <td>Storage Events</td>
                      <td>SVG Events</td>
                      <td>Tab Events</td>
                      <td>Text Composition Events</td>
                    </tr>
                    <tr>
                      <td>Touch events</td> 
                      <td>Uncategorized Events</td>
                      <td>Update Events</td>
                      <td>Value change Events</td>
                      <td>View Events</td>  
                    </tr>
                    <tr>
                        <td>Websocket Events</td>
                        <td>Window events</td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>


                  </table>



                  
                  
                  DOM Element Object Methods: <br />
                  <br />                  
                  <span class="inline-code">addEventListener()</span> - attaches an event handler to the specified ("input") element. Ex.:
                  <br /><br />
                  Attach a <strong>click event</strong> to a &lt;button&gt; element. <br />
                  When the user clicks the button, output "Hello World" in a &lt; p &gt; element with id="demo":
                  
                  
                  <code>
                  document.getElementById("myBtn").addEventListener("click",
                  function(){
                    document.getElementById("demo").innerHTML = "Hello World";
                  });
                  </code>
                  <br />
                  Syntax:
                  <code>
                  eventTarget.addEventListener(type,listener,[,useCapture]);
                  </code>
                  <br />
                  *The <span class="inline-code">useCapture</span> of <span class="inline-code">addEventListener</span> is what will know the capturing and bubbling states. By default, useCapture is false - meaning it's in the bubbling phase.
                  
                  
                  
                  <li>document.getElementById("myBtn") - use document object's getElementById() method to target the element with ID "myBtn"</li>
                  
                  <li>.addeventListener("click", function(){…} - use the DOM element object's addEventListener() method to attach (or add) a click <strong>(input)</strong> (event)to the button #MyBtn, and then run a function (the event handler):</li>
                  
                  <li>function(){document.getElementById("demo") - the <strong>(output)</strong> <p> element whose inner content will be modified when the input element, #myBtn, is clicked.</li>
                  
                  <li>.innerHTML = "Hello World" - adds the innerHTML <strong>property</strong> with the new content that will be updated on click</li>
                  <br /><br />
                  
                  <h3>Most Common JS Events</h3>
                  <li>click</li>
                  <strong><li>input</li></strong>
                  <li>mouseenter</li>
                  <li>mouseleave</li>
                  <li>mousedown</li>
                  <li>mouseup</li>
                  <li>mousemove</li>
                  <li>keydown</li>
                  <li>keyup</li>
                  <li>blur</li>
                  <li>focus</li>
                  
              
  
                  <h2>Events in JS</h2>
                  
                  There are two main ways to handle/get notified of DOM events:
                  <li>addEventListener()</li>
                  <li><strong>on-event</strong> handlers</li>
                  
                  <h3>on-event Handlers</h3>
                  The on-event handler is usually named according to the event it's designed to react to, such as <span class="inline-code">onclick</span>, <span class="inline-code">onfocus</span>, <span class="inline-code">onkeypress</span>, etc.
                  
                  
                  <h3>DOM Events</h3>
                  
                  Each event is going to have a corresponding event object as its "type".
                  <br />
                  <a href=https://www.w3schools.com/jsref/dom_obj_event.asp" target="_blank">
                  List of all Dom Events
                  </a>
                  
                  
                  <h3>DOM Event Objects</h3>
                  Any event is going to belong to a certain event object - for example, the mouse click event belongs to the MouseEvent object. <br />
                  All event objects are based on the Event Object; <strong>
                  they inherit all of its properties and methods</strong>.
                  
                  <h4>The  Event Object</h4>
                  This is the parent of all other event objects. It has the following methods, properties and associated event types.
                  
                  <a href="https://www.w3schools.com/jsref/obj_event.asp" target="_blank">
                  Event Object Methods, Properties and Types
                  </a>
                  
                  <br /><br />
                  
                  
                
                  Event "types" for individual DOM events = corresponding event objects <br/ >
                  
                  
                  With dom event manipulation that also relates to (adds/removes css classes), be sure and troubleshoot the CSS, not just the JS. <br/ >
                  
                  
                  <h4>List of all Event Objects</h4>
                  https://www.w3schools.com/jsref/obj_animationevent.asp
                  
                  
                  
                  HTML events are <strong>things that happen to HTML elements</strong>. Javascript can "react" on these events.
                  
                  <h3>HTML DOM Events</h3>
                  
                  An HTML DOM Event allows JS to register different event handlers on elements in an HTML document. <br /><br />
                  They're usually <strong>in combination with functions</strong>, and the function will be executed when the specified event (i.e. click). 
                  
                  
                  
                  
                  
                  
                  
                  An HTML event is either a. <strong>something the browser does</strong>, or b. <strong>something the user does</strong>. Examples of HTML events:
                  <li>An HTML web page finishes loading</li>
                  <li>An HTML input field was changed</li>
                  <li>An HTML button was clicked</li>
                  <br />
                  
                  <strong>event handler</strong> - a block of code, <strong>usually a user-defined JS funfction</strong>, that runs when the event is triggered (so on mouse click, run function using event handler). <br /><br />
                  When this function is defined to be run in response to that even triggering, it's called <strong>registering an event handler</strong>. <br /><br />
                  
                  Event handler and event listener are usually interchangeable terms, although the listener listens for the event happening, and the handler is the actual code run in response to the event happening. (so <span class="inline-code">addEventListener()</span> is both the event LISTENER and the event HANDLER - the handler is the function called in the listener).
                  
                  
                  
                  
                  
                  
                  
                  
                  <code>
                  document.getElementById("coolBtn") //target the "input" element to be listened to (#coolBtn)
                  .addEventListener("click", //attaches event listener, click, to targeted element
                  function(){ document.getElementById("demo)} /* the event handler that contains the code (function) to be run when the event 
                  being listened to is triggered - targeting the p element #demo */
                  .innerHTML = "Hello World" // the method performed on the "output" element (#demo)
                  </code>
                  
                  
                  
                  
                  
                  <h3>Event Capturing vs Event Bubbling</h3>
                  
                  If you have two elements, 1 and 2, and 2 is inside of 1, you can attach an event handler to both elements, such as onClick. Now when 2 is clicked on, <strong>the handler for both elements is executed</strong>. In what way that order executes is going to either be event capturing or event bubbling. In capturing, 1 executes first (so trickle-down on the elements); in bubbling, 2 would execute first (bubble upwards to parent elements).
          


       
                <h3>Resources</h3>
    

                <a href="https://www.w3schools.com/jsref/dom_obj_document.asp" target="_blank" rel="noopener noreferrer"> Document Object Methods and Properties</a>
                <br />

                <a href="https://www.w3schools.com/jsref/dom_obj_event.asp" target="_blank">DOM Events List</a> <br />
    
                <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank">Comprehensive Guide to UI Events</a>
                </article>
                </section>




          <section class="main-section" id="CSS3">
            <header>CSS3</header>
            <article>
            <h2 id="cssBox">Box Model</h2>

              <p>
              
              All HTML elements can be considered as boxes. The term "box model" is used when talking about a. Design and b. Layout.
              <br /><br />
              It wraps around every HTML element.
              </p>
              <strong>content</strong> - The innermost layer containing text or other elements of the target element <br />
              <strong>padding</strong> - the layer just outside the content layer. The padding is transparent.
              More padding gives visual effect of increasing the size of the content layer. <br />
                
              <strong>border</strong> - 
              the layer surrounding padding. Most of the time has a small width of maybe only 1 pixel. 
              Unlike padding and margin layers, this layer can be given color and style.	<br />
              <br />
              <strong>margin</strong> - the outermost layer between the target element and its parent element. The margin is transparent. <br />
              Adding space to the margin gives the visual effect of increasing the content size of the parent element. <br /><br />
              
              When you set the width and height properties of an element with CSS, you just set the width and height of the content area. <br />
              To calculate the full size of an element, you must also add padding, borders and margins. <br /><br />
              
              <strong>total element width</strong> = (width) + (left + right padding) + (left + right border) + (left + right margin) <br />
              
              <strong>total element height</strong> = (height) + (top + bottom padding) + (top + bottom border) + (top + bottom margin) <br /><br />
                  
            <h2 id="cssVar">CSS Variables and Custom Properties</h2>
              
              <strong>CSS variables</strong> - entities containing specific values to be reused throughout a document.
              <br /><br />	
              They're set using <strong>custom property notation</strong> (ex. —main-color: black;i).<br />
              They're accessed using the var() function (ex. var(—main-color);). <br /><br />
              
              Complex websites have very large amounts of CSS, often with a lot of repeated values. <br />
              The same color might be used in hundreds of different places, requiring global search and replace if that color needs to be changed. <br /><br />
              
              Variables address the problem that CSS is mostly a declarative language that lacks dynamic capabilities. <br />
              
              <h3>CSS Variables vs. Preprocessor Variables</h3>
              
              <p>
              CSS variables are live CSS properties running in the browser, while preprocessor variables have to get compiled into regular CSS code, therefore the browser knows nothing about them.
              </p>
              
              <p>
              What this means is you can update CSS variables in a stylesheet document, inside the inline style attributes and SVG presentational attributes of an HTML file, or choose to manipulate them on the fly using Javascript. You can't do this with preprocessor variables.
              </p>
              
              <p>
              CSS variables allow for one canonical declaration of a CSS property (that  can be referenced throughout, and then changed at the root as desired to update across the whole stylesheet). <br /><br />
              
              If no value is set for a custom property on a given element then the value of its parent is used.
              </p>
            
            
            <h3>CSS Variable Syntax:</h3>
              
              <code>
              —my-background: #000;
              </code>
              
              1. prefix the custom property with two dashes, <br />
              2. assign it a value like a regular CSS property <br /><br />
              
              The value is referenced using var(), and is scoped inside a CSS selector:
              <code>
              :root{
              —my-background: #000;
              }
              /* rest of the CSS file */
              #foo{
              background-color: var(—my-background);
              }
              </code>
              
              <h3>Use CSS Variables in Javascript</h3>
              
              It's the same as standard properties like background-position: <br /><br />
              
              If you have:
              <code>
              :root{
                —mouse-x: 10px;
                —mouse-y: 10px;
              }
              </code>
              
              Then to update those values from JS you'd use:
              <code>
              let root = document.documentElement
              
              root.addEventListener("mousemove"m e=> {
                root.style.setProperty('—mouse-x', e.clientX + "px");
                root.style.setProperty('mouse-y', e.clientY + "px");
              });
              </code>
              
              <h3>Nesting CSS Variables</h3>
              
              You can set the value of a CSS variable with another CSS variable, ex.:
              
              <code>
              :root{
              —top-color: orange;
              —bottom-color: yellow;
              
              —my-gradient: linear-gradient(var(—top-color), var(—bottom-color));
              }
              </code>
            
            <h3>CSS Variables with SVGs</h3>
              
              You can use CSS variables to modify both a. style and b. presentational attributes inside inline SVGs.
              <br /><br />
              Ex.:
              <code>
              svg
              symbol id="close-icon" viewbox 0 0 200 200
              circle cx="96" cy="96" r="88" fill="none" stroke="var(—icon-color)" stroke-width="15"
              /symbol
              /svg
              </code>
            
            
            <h2 id="cssMedia">Media Queries</h2>
              
              Adjust styles according to factors like:
              
              <li>device used,</li>
              <li>viewport size, </li>
              <li>screen's pixel density</li>
              <li>device orientation</li>
            
            
            <h3>Optimize Text For Reading:</h3>
              <p>
              An ideal column should contain 70-80 characters per line, or about 8 to 10 words in English. So, <strong>each time the width of a text block grows past 10 words, consider adding a breakpoint.</strong>
              </p>
              
              <p>
              Don't define breakpoints based on device classes - defining them based on specific devices or operating systems can result in a maintenance nightmare. Instead, the content itself should detemrine how the layout adjusts to its container. So, <strong>don't define breakpoints based on the device being used, but instead on the content!</strong>
              </p>
              
              <p>
              Can design for the smallest mobile device first: pick major breakpoints by starting small, then working up.<br />
              Try designing the content to fit on a small screen size first, then expand as breakpoints become necessary.
              <br /><br />
              *Use DevTools to view the various breakpoints:
              </p>
              
              1. Open DevTools and turn on Device Mode <br /><br />
              2. Use viewport controls to set to Responsive mode <br /><br />
              3. Click the three dots in the top right and select Show Media Queries <br /><br />
              
              <li>Queries that are blue-colored target a maximum width</li>
              <li>Green queries target widths within a range</li>
              <li>Orange queries target a minimum width</li> <br />
              
              <strong>Can even load different style sheets with different breakpoints depending on the browser size:</strong>
              <code>
              &lt;link rel="stylesheet" href="weather.css"&gt; /*could be main styles -anything not media queried */
              &lt;link rel="stylesheet" media="(max-width: 600px;)" href="weather-2-small.css"&gt;
              &lt;link rel=""stylesheet" media="(min-width: 600px;)" href="weather-2-large.css"&gt;
              </code>
              
              <strong>@media</strong> - used to define a media query, preceding a media type
              
            <h3>Media Types</h3>
              
              <li>all</li>
              <li>print</li>
              <li>screen</li>
              <li>speech</li>
              <li>When not specified, the type of all is implied</li>
              
              Multiple media types can be used at once, and are separated by commas:
              <code>
              @media screen, print{
                /*styles*/
              }
              </code>
            
            <h3>Media Features</h3>
              <p>
              Media features provide more specific details to media queries by allowing to test for a specific feature of the user agent or display device.
              </p>
              
              <li>max-width, min-width</li>
              <li>max height, min-height</li>
              <li>resolution (using dpi or dpcm)</li>
              <li>aspect-ratio</li>
              <li>orientation</li>
              <li>resolution</li>
              <br />            

              <a href="https://www.quackit.com/css/css_media_features.cfm" target="_blank">Full list of Media Features</a>
              
              <code>
              /*hide an element when the browser's width is 600px wide or less*/
              @media screen and (max-width: 600px) {
                div.example{
                  display: none;
                }
              }
              </code>
              
              
              <strong>max</strong>-width = <strong>less</strong> than the amount, or the amount (think "up to" 700px with max-width: 700px). <br />
              <strong>min</strong>-width = <strong>more</strong> than the amount, or the amount (think "down to" 700px with min-width: 700px).
              <br /><br />
              Ex.:
              
              <code>
              //Set the background-color to lavender if the viewport is 800px or wider,
              //set to light green if between 400 and 799px,
              //or set to lightblue if smaller than 400px:
              
              body{
                background-color: lightblue;
              }
              
              media screen and (min-width: 400px){
                body {
                background-color: lightgreen;
                }
              }
              
              media screen and (min-width: 800px){
                body{
                background-color: lavender;
                }
              }
              </code>
            
            <h3>Media Queries with CSS Grid</h3>
              <strong>grid-template-areas</strong> - Allows you to write responsive layouts with a single rule inside a media query.
              <br /><br />
              
              It defines a <strong>visual grid</strong> system on both axes at once:
              <code>
              .user-profile__username{
                grid-area: name;
              }
              
              .user-profile__avatar{
                grid-area: avatar;
              }
              
              .user-profile__bio{
                grid-area: bio;
              }
              
              .grid{
                grid-template-areas:
                'avatar name'
                'bio    bio'
              }
              
              /* a simple media query will rearrange the grid template:*/
              @media (max-width: 700px){
                .grid{
                'name'
                'avatar'
                'bio';
                }
              }
              /*the children element of grid - name, avatar, and bio - will now stack vertically in a viewport up to 700px */
              </code>
              <p>
              The number of columns is inferred by the property values. <br />
              Each name separated by on or more spaces defines a column (and each row must define the same number of columns). <br /><br />
              </p>
              
              <a href="https://www.w3schools.com/cssref/tryit.asp?filename=trycss_grid-template-areas3" target="_blank">
              w3 example of CSS grid using grid-template-areas
              </a>
            
            <h3>Easy Fluid Images</h3>
              
              Can set images on a website to:
              <code>
              img {
                    max-width: 100%;
              }
              </code>
              <p>
              Instead of rendering at its native width and therefore overflowing its containing box, the image will render at its native dimensions, as long as its width doesn't exceed the width of its container. </p>
              <br />
              
              <a href="http://unstoppablerobotninja.com/demos/resize/" target="_blank">
              Example
              </a>
            
            <h2 id="cssSelect">CSS selectors & Combinators</h2>
              
              <a href="https://www.w3schools.com/cssref/css_selectors.asp" target="_blank">
              Fill List of CSS Selectors
              </a> <br /><br />
              
              
              <a href="https://www.w3schools.com/css/css_combinators.asp" target="_blank">
              Combinators
              </a>        
            <h2 id="cssMeasure">Measurements</h2>
              
              <strong>px</strong> - good at spacing and layout but are not a good fit for font-size. <br />
              <strong>em</strong> - values relative to the parent element. <br />
              If font-size of parent is 20px then 1 em = 20px. <br />
              So if the child element has 1.5 em then it would = 30px. <br />
              <strong>rem</strong> - values are relative to root html element instead of the parent element. <br />
              So, if font-size of the root element is 16px then 1 rem = 16px. <br />
              <strong>vw</strong> - relative to 1% of the width of the viewport. <br />
              If the viewport is 50cm wide, then 1vw = .5cm. <br />
              <strong>vh</strong> - relative to 1% of the height of the viewport <br />
              <strong>vmin</strong> - relative to 1% of the viewport's smaller dimension <br />
              <strong>vmax</strong> - relative to 1% of the viewport's larger dimensions <br />
              <strong>%</strong> - relative to the parent element <br />
              
            <h2 id="cssKey">Keyframes</h2>            
            <h2 id="cssGradient">Gradients</h2>
              background-image: linear-gradient(direction, color-stop1, color-stop2, ...);
              
            
            <h2 id="cssSVG">SVG</h2>
              <p>
              <strong>symbol tag</strong> - creates an invisible version of the SVG graphic which can then be instantiated as a visible copy of the same graphic with the <use> tag (probably to de-clutter sections of the HTML document where SVGs would be used and to separate out).
              </p>
              
              <a href="https://www.sitepoint.com/build-svg-icons/" target="_blank">
              Build Your Own SVG Icons
              </a>

            <h2 id="cssGrid">CSS Grid</h2>
                <p>CSS Grid - A CSS module that's most powerful layout system available in CSS.
                <br /><br />
                It's 2-dimensional system, meaning it handles both columns and rows, versus flexbox which is largely 1-dimensional.<br /><br />
                
                With Grid, you apply CSS rules to both a parent element, which becomes the Grid Container, and that element's children, which become Grid Items.

                </p> 
                
                <h3>Steps to setting up a grid</h3>
                <p>
                1. Define a container element as a grid with display: grid<br />
                2. Set the column and row sizes with grid-template-columns/rows<br />
                3. Place the child elements into the grid with grid-column and grid-row. <br />
                
                ex.:
                
                <code>
                div class="container"
                  div class="item item-1"
                  div class="item item-2"
                  div class="item item-3"                              
                </code>
                </p><br />
                <li> Source order of the grid items doesn't matter - the CSS can place them in any order, making it easy to rearrange the grid with media queries.</ul>
                
                <li> With CSS Grid, you can define the layout of an entire page, then completely rearrange it to accomodate a different screen width, all with only a couple lines of CSS.
                
                <li> Except for IE, all browsers ship native, unprefixed support for Grid.
                
                <br /> <br />
                <h3>Using CSS Grid With Webpage Layouts</h3>
                <p>
                <Strong>grid-area</strong> - Gives an item a name so it can be referenced by a template created by the grid-template-areas property. <br />
                </p>
                Values: <br />
                <li><strong>name</strong> - your chosen name (i.e. "header")</li>
                <li><strong>row-start / column-start / row-end / column-end</strong> - can be numbers or named lines.</li>
                <code>
                .item {
                  grid-area: <strong>name</strong> | <strong>row-start</strong> / <strong>column-start</strong> / <strong>row-end</strong> / <strong>column-end</strong>;
                }
                </code>
                
                Example - Assigning a name to an item:
                <code>
                .item-d {
                  grid-area: header
                }
                </code>
                
                Example - Specifying an item's area using shorthand:
                
                <code>
                .item-d {
                  grid-area: 1 / col4-start / last-line / 6
                }
                </code>
                <p>Here's a visualization of the above code:</p>
                <img src="images/css-grid-example.png" height="300">

                <p><Strong>grid-template-area</strong> - Defines a grid template by referencing the names of the grid areas that are specified with the grid-area property:</p>

                <img src="images/css-grid-layout.png" height="300">
                  <br /> <br />
                  *Each row in the declaration needs to have the same number of cells.
                  
                <h3>CSS Grid Terminology</h3>

                <p>Grid Container - The element on which display: grid is applied.
                  </p>
                <p>Grid Item - The children, i.e. direct descendants of the container. In the following, the item elements are grid items, but the sub-item isn't:</p>

                <code>
                    div class="container"
                      div class="item"
                      div class="item"
                        p class="sub-item"
                      div class="item"
                  
                    </code>

                    <p><strong>Grid Line</strong> - The dividing lines that make up the structure of the grid.
                    They can be either vertical (column grid lines) or horizontal (row grid lines), and reside on either side of a row or column.
                    </p>

                    <p><strong>Grid Track</strong> - The space between two adjacent grid lines - i.e. the content in the columns and rows of the grid.</p>
                    <p><strong>Grid Cell</strong> - The space between two adjacent row and two adjacent column grid lines. It's a single "unit" of the grid.</p>
                    <p><strong>Grid Area</strong> - The total space surrounded by four grid lines. It may be comprised of any number of grid cells.
                      </p>
                      <h3>Resources</h3>
                      <a href="https://css-tricks.com/snippets/css/complete-guide-grid/#prop-display">Grid Container and Grid Item Properties</a><br /><br />
                      <a href="https://itnext.io/simple-web-layout-with-css-grid-ec6be5086531">Simple Webpage Layout with CSS Grid</a>

                      <a href="https://www.w3.org/TR/?title=css" target="_blank">CSS Standard Guides</a>
            
            <h2 id="cssVend">Vendor Prefixes</h2> 

              -webkit: Chrome, Safari, almost all iOS browsers<br />
              -moz:     Firefox<br />
              -o:	    Old versions of Opera<br />
              -ms:       IE and Edge<br />            
               
              

            <h2 id="cssAnim">Animations</h2>
            <h3>Animation Basics</h3>      
              
              -should be snappy <br />
              -durations should be kept short <br />
              -should take advantage of easing <br />
              -you should choose ease-out animations for UI elements (i.e. onclick) <br />
              -avoid ease-in or ease-in-out animations unless you can keep them short - they tend to feel sluggish to end users. <br /><br />
              
              <strong>easing</strong> - an animation that starts slowly and accelerates - it's the process of making an animation less "severe" or pronounced.<br />
              <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/the-basics-of-easing" target="_blank">
              (easing basics)</a>
              
              
            <h3>Animating Between Views</h3>
              
              <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/animating-between-views" target="_blank">
              Full guide to animating between views with CSS and JS
              </a>
              
              <h4>Use translations to move between views: </h4>
              
              *Avoid using left, top or any other property that triggers layout (so instead use translate(100%) for example). <br />
              *Assume that there are two views, for example: a list view and a details view. As the user taps a list item inside the list view, the details view slides in, and the list view slides out. <br /><br/>
              
              To achieve this effect you need a <strong>container</strong> for both views that is set to <span class="inline-code">overflow:hidden</span>. <br />
              This way,both views can be inside the container side-by-side without the need for a horizontal scrollbar, and each view can slide side-to-side inside the container as needed. <br /><br />
              
              CSS container:
              <code>
              .container {
                width: 100%;
                height: 100%;
                overflow: hidden;
                position: relative;
              }
              </code>                    
            <h2 id="cssDisadvantage">CSS Disadvantages</h2>
              <p>CSS has always been used to do layouts, but using tables, floats, positioning and inline-block are all essentially hacks which left out a lot of important functionality, like vertical centering.</p>

            <h2 id="cssTips">Tips</h2>
              *Width and height values can exceed 100%.  <br />     <br />
                        
              *When doing colors on things like tables:  <br />

              *Having 8 COLORS (4 that are each supposed to be complementary with another 4, well, DON'T do that. That's a lot more ridiculous than it sounds.  <br /> <br />
              *Mock it up even if a screenshot with photoshop - bg, text, buttons can be layered via cut.
              <br /> <br />
              *Have colors typed out as names for css in textedit- makes actually writing css for them easier.
              <br /> <br />
              *Keep all related styles in same area in css. <br /> <br />
              
              *If changing colors alot esp. in CSS, use highlight -> cmd+d to select it 'linearly" and change more quickly. <br /> <br />
              
              *Do NOT have a bunch of different stylesheets for the same project (unless done properly like for modularity) - like a style.css, a responsive.css.  <br /><br />

              reisizing an element easily vs other similar elements (transform-scale):
              <code>
              .highlight .pricing-box {
                box-shadow: 0px 0px 40px rgba(200, 200, 200, 0.9);
                transform: scale(1.15);
                -webkit-transform: scale(1.15);
                -moz-transform: scale(1.15);
                -ms-transform: scale(1.15);
                -o-transform: scale(1.15);
              }
              </code>








            <h2 id="cssLinks">Links</h2>
            
              <a href="https://css-tricks.com/" target="_blank">
              css-tricks.com
              </a>  <br/>
              
              <a href="https://css-tricks.com/snippets/css/retina-display-media-query/" target="_blank">
              Retina display media queries
              </a>  <br/>


              <a href="https://css-tricks.com/bem-101/" target="_blank">
                <h4>BEM Methodology</h4>
                </a> <br /><br />
                
                <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" target="_blank">
                <h4>CSS Object Model</h4>
                </a> <br /><br />
                
                <h4>Child and Parent Elements</h4>
                
                Syle child elements individually without redundant css: <br /><br />
                <strong>.className:nth-child(1)</strong> - selects FIRST child element <br />
                <strong>.className:nth-child(2)</strong> - selects SECOND child elem <br />
                <strong>.className:nth-child(3)</strong> - selects THIRD <br /><br />
                Ex.: <br /><br />
                <strong>.call-out</strong> = has 3 child elems. <br />
                <strong>.call-out:nth-child(1){background-color: #ff0000;}</strong> -->> selects and styles the first <br /><br />
                
                <h4>Properly enable responsiveness on a webpage</h4>
                <code>
                &lt; meta name="viewport" content="width=device-width, initial-scale=1" &gt;
                </code>
                
                This tells the browser to set the width of the content to the width of the device itself, and to scale that content to 1 on page load. <br /><br />
                <a href="https://responsivedesign.is/develop/responsive-html/viewport-meta-element/" target="_blank">
                Viewport Options
                </a>
                
                <h4>Call-to-actions</h4>
                Can be a button, or banner, or text or anything. <br />
                Prompts the user to CLICK it. <br />
                For an "immediate" interaction like to buy a specific product or service. <br />
                CTA testing can be done in A/B Testing to see which of severla graphics have the highest click success rate. <br />                                          
            <h2>Terms</h2>
              responsive layout <br />
              set viewport <br />
              fluid widths <br />        
              overflow <br />   
              position <br />                                          
            </article>
            </section>            
          <section class="main-section" id="Bootstrap">
              <header>Bootstrap</header>
              <article>
                <h2>Grid Structure</h2>
              <img src="images/grid-structure.jpg" alt="" style="width: 70%;">
              <h2>Useful Bootstrap Plugins</h2>
              <a href="https://www.eyecon.ro/bootstrap-datepicker/" target="_blank"> 
              Datepicker
              </a><br />
              <a href="http://www.daterangepicker.com/" target="_blank">
              Date Range Picker
              </a><br />
              <a href="http://botmonster.com/jquery-bootpag/#.XIquShNKjOT" target="_blank">
              bootpag
              </a> - Dynamic Boostrap pagination<br />
              </article>          
            </section>   

          <section class="main-section" id="Design">
            <header>Design Basics</header>
            <article> 
              <img src="images/design-color-theory.png" alt="" height="400">
              <h2>Wireframing</h2>      
                <strong>wireframe</strong> - the blueprint of your site <br />
    
                Example Steps:<br />
                1. Draft the design<br />
                2. Organize the content in html<br />
                3. Format in css<br />
                4. Ensure cross-browser compat.<br />
                5. Check validity/testing<br />
                6. Final code<br /><br />
    
                <p>Number of ways different designers go from design to implementation:<br />
                <li>Wireframe -> Interactive Prototype-Visual -> Design</li>
                <li>Sketch -> Code</li>
                <li>Sketch -> Wireframe -> Hi-Def Wireframe -> Visual -> Code</li>
                <li>Sketch -> Wireframe -> Visual -> Code</li></p>

              <h2>UX</h2>
              <h3>UX Principles</h3>

                *Empathy beats intuition - just think about it from the viewpoint of someon clicking around on your site. <br />
                *Knowing the essentials - putting together points, lines and planes in a combination and bring color into the equation. Any UI component can be created.<br />
                *Good design is as little design as possible (aids usability)<br />
                *Optimize legibility <br />
                *Typographic hierarchy (i.e. consistency) <br />
                *Prototype and test with users and then iterate in response <br />
                *Improve accessibility with contrast between foreground and background colors <br />
                *Releasing minimum viable products early and testing them with actual users, moving from alpha to beta to live to adding features <br />
                *According to a UserTesting report, every dollar invested in UX can return between $2 and $100 <br />
                *As a UX designer, your first task in a new job is clearly explaining the value you'll be bringing to the company and how you'll bring that about. <br />
                *Iteration reduces risk <br /> <br />


                Someone who is a UX specialist looks more at the human side of the design process, and would tend to do research and ask questions that will form the basis for coming up with design concepts/ideas, and then also doing user testing and evaluation to validate these ideas post development (or as part of the development cycle). <br /><br />

                If you really want to cut through all the jargon and terminology, UX is really just a concept/approach. So if you think more like a user (i.e. from a goal driven perspective) rather than a developer (i.e. from a specification/implementation perspective) then you are on a good path to becoming a UX practitioner. <br /><br />

                This is what they refer to as the <strong>user-centric</strong> approach to design and development. <br /><br />

                In comparison, UI is a little less abstract because it deals directly with the user interface aspect, and although it can be as high level as creating design patterns and libraries, you can also get down to specific details like individual UI components and elements. <br /><br />

                Problems for user-centric approach in very small teams is that we don't necessarily have enough time dedicated to users. <br /><br />

                Front-end developer = foreman, can BUILD things, but might not understand how buildings should be created.
                An experienced foreman relies on things like municipal building codes ("design patterns") to guide construction, but the end result MAY END UP HARD TO USE OR UNATTRACTIVE. <br />

                UX = architect, trained in understanding spaces, how people will use the building and move through it, etc.
                They may not have the ability to plaster a wall o drive a nail however, and as a result THEIR MORE ADVENTUROUS DESIGNS MIGHT BE CHALLENGING TO BRING THE REAL WORLD. <br /><br />

                As a front-end dev, you're the foreman and construction crew all rolled into one, but YOU MIGHT NOT BE AN ARCHITECT (yet) - you may not have the training about HOW to design the software for the best UX.<br /><br />

                You can draw on examples from the world around you to produce *functional* apps, but it may not be sufficient to produce *usable* apps. <br /><br />

                Good news is you can learn UX techniques that will help you to: <br />
                -Understand user needs <br />
                -Create designs to meet those needs, and <br />
                -Test those designs with real live users to verify.<br /><br />

              
              <h3>UX Stages</h3>
                
                1. <strong>Initial stages</strong> <br /><br />
                This is where the research happens. <br />
                A UX designer will generally get a brief from the client or manager asking them to do some project research.<br />
                If ___ wants a new app, the UX designer would combine DESK-BASED and FIELD research to get a full picture of who they're designing for.<br /><br />
                This might include:<br />
                -Reviewing what the current site has to offer.<br />
                -<strong>Interviewing existing users</strong> to identify <strong>opportunities</strong> and <strong>pain points</strong>.<br />
                -<strong>Doing competitor research</strong> to see what else is out there.<br />
                
                <p>
                These tasks will enable the UX designer to <strong>pinpoint the core features needed</strong> for the <strong>minimum viable product</strong> and start <strong>drafting some initial personas</strong>.
                </p>
                <p>
                For example, for a food app the core features might be a menu, the ability to make online reservations and a branch finder.
                </p>
                
                2. <strong>Personas and information architecture</strong><br /><br />
                
                With the core features having been decided on, it's time to figure out what <strong>tasks</strong> 
                each persona wants to perform and <strong>why</strong>.
                <br /><br />
                An example persona for a food app might be Lucy, a go-getting 20-something who likes eating artisan salads on her lunch break. <br />
                An example task for her would be: <br />
                "Lucy likes to pre-order the salad via the app on the phone, as it saves her time between meetings."<br />
                <p>
                Once this process has been completed for each persona being considered, then it's possible to REFINE THE CONTENT *NEEDED*, working out the information architecture and SITE MAP and beginning PAPER PROTOTYPES.
                </p>
              
                These are very rough sketches which can be shown to colleagues, and quickly and easily improved.
                <br /><br />
                
                3. <strong>Wireframes and user testing </strong><br /><br />
                After paper prototypes comes WIREFRAMES, USER TESTING, and plenty of ITERATING. <br />
                Wireframes typically go through many stages and there's no right/wrong way of doing them.
                <br /><br />
                
                They often start as very basic b&w designs moving on to interactive designs where users can navigate between the different pages, as they would with the final product, to high-res designs which give the user a really clear idea of what the end product will look like. <br /><br />
                **Each stage is punctuated with user testing and iterations.**
                <br /><br />
                4. <strong>Visual design</strong><br /><br />
                
                During the visual design stage, wireframes are converted into <strong>mock-ups</strong>. <br /><br />
                
                These include the final <strong>imagery</strong>, <strong>color</strong>, and <strong>typography</strong>. <br />
                
                <p>
                The main focus is the <strong>look</strong> and <strong>feel</strong> - they should be <strong>pixel-perfect</strong> and show exactly what the design will look like when brought to life so they can be used as a guide when development starts. <br /><br />
                
                Some UX designers do the visual design themselves using Photoshop etc, but others might choose to use a digital designer/front-end dev to get the design just right.
                </p>
              
              <h3>Definitions</h3>
                
                Dynamic sectors <br />
                <a href=" http://theuxreview.co.uk/personas-the-beginners-guide/" target="_blank">
                Persona (UX)</a> <br /> - The "person" you're using as a basis for whom you're designing the site. <br />
                Information Architecture<br />
                Core features of a website<br />
                Paper prototyping<br />

                <a href="https://www.usability.gov/how-to-and-tools/methods/writing-for-the-web.html" target="_blank">Usability guide for writing user-friendly content</a> <br />&nbsp;
                  
              <h3>Links</h3> 

                <a href="https://www.smashingmagazine.com/2016/05/easy-steps-to-better-logo-design/" target="_blank" rel="noopener noreferrer">Logo/SVG Design Fundamentals</a>

            </article>
            </section>                  
      
          <section class="main-section" id="Sass">
              <header>Sass/SCSS</header>
              <article>

                  <h2>.sass vs .scss</h2>
                  <p>
                  When Sass first came out its syntax was noticeably different from CSS - it looked a lot like Haml.
                  In version 3 Sass changed its main syntax to .scss, which is a superset of CSS. You can still use Sass syntax but .scss and its syntax is considered more accessible to those who already know CSS (the terms Sass and SCSS can be seen as essentially interchangeable - SCSS is just "newer Sass" syntax that's made to be more familiar).
                  </p><br />
                  Sass allows you to get more done in less code, more readably, and in less time.
                  
                  <h2>Sass Variables</h2>
                  
                  <p>Variables always start with an $, ex.:</p>
                  <code>
                  $variable-name: variable-value;	
                  </code>
                  
                  <p>Example with HTML:</p>
                  <code>
                  div class="heading"
                    h1 class="heading-primary"This is a primary heading                    
                    h2 class="heading-secondary">This is a secondary heading                
                  </code>
                  
                  <p>Then define two variables for primary and secondary colors:</p>
                  <code>
                  $color-primary: #000;
                  $color-secondary: #fff;
                  </code>
                  
                  <p>Then style the above headings:</p>
                  
                  <code>
                  .heading-primary{
                    color: $color-primary;
                    text-align: center;
                  }
                  
                  .heading-secondary{
                    color: $color-secondary;
                    text-align: center;
                    margin-top: 15px;
                  }
                  </code>
                  
                  <p>After compilation, the variables are replaced by their actual values in CSS.</p>
                  
                  <h2>Nesting CSS</h2>
                  
                  <p>CSS doesn't support selector nesting. With Sass, you can nest child selectors inside the parent selector.
                  <br /><br />
                  Instead of having to write:</p>
                  
                  <code>
                  .navigation{
                  background-color: yellow;
                  padding: 10px;
                  }
                  
                  .navigation ul {
                    list-style: none;
                  }
                  
                  .navigation li {
                    text-align: center;
                    margin-top: 10px;
                  } 
                  </code>
                  <p>
                  With the above, you're having to repeat the <span class="inline-code">navigation</span> class name every time you want to style its children. Instead use nested selectors:</p>
                  
                  <code>
                  .navigation{
                    background-color: yellow;
                    padding: 20px;
                  
                    ul{
                      list-style: none;
                    }
                  
                    li{
                    text-align: center;
                    margin-top: 20px;
                    }
                  }
                  </code>
                  
                  <h2>Mixins</h2>
                  <p>
                  Mixin syntax:
                  </p>
                  <code>
                  @mixin mixin_name(){
                    //
                  }
                  </code>
                  
                  
                  <p>A <strong>mixin</strong> is a reusable piece of code similar to a function. It allows you to make <strong>groups</strong> of CSS declarations to be reused throughout the site.</p>
                  <p>You can also pass in values to make mixins more flexible. <br /><br />
                  An example of a mixin is for vendor prefixes:</p>
                  
                  <code>
                  @mixin transform($property){
                    -webkit-transform: $property;
                    -ms-transform: $property;
                    transform: $property;
                  }
                  
                  .box { @include transform(rotate(30deg)); };
                  </code>
                  <p>
                  1. Create a mixin using the @mixin <strong>directive</strong> and give it a name. In the above, it's named transform.
                  2. The variable <span class="inline-code">$property</span>  inside the parantheses is used to pass in a transform of whatever we want.
                  3. You can then use the mixin as a CSS declaration starting with <span class="inline-code">@include</span> followed by the name of the mixin. 
                  </p>
                  <p>
                  So the above compiles down to:
                  </p>
                  <code>
                  .box {
                    -webkit-transform: rotate(30deg);
                    -ms-transform: rotate(30deg);
                    transform: rotate(30deg);
                  }
                  </code>
                  <p>
                  Another mixin example:
                  </p>
                  
                  <code>
                  @mixin absCenter(){
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    tranform: translate(50%, -50%);
                  }
                  
                  .box{
                    background-color: red;
                  
                    div{
                      width: 200px;
                      height: 200px;
                      background-color: blue;
                      @include absCenter;/*this works even on nested elements: the div now has:
                      position: absolute;
                      top: 50%;
                      left: 50%;
                      transform: translate(50%, -50%);
                    }
                  </code>
                  
                  <p>
                  You can also pass arguments to the mixins:
                  </p>
                  <code>
                  @mixin box-shadow-vendor($x, $y, $blur, $spread){
                    -webkit-box-shadow: $x $y $blur $spread;
                    -moz-box-shadow: $x $y $blur $spread;
                    -mos-box-shadow: $x $y $blur $spread;
                    -box-shadow: $x $y $blur $spread;
                  }
                  
                  .box{
                    background-color: red;
                  
                    div{
                    @include absCenter;
                    @include box-shadow-vendor(0, 5px, 5px, #fff);
                    }
                  }
                  </code>
                  
                  <h2>Functions in Sass</h2>
                  <p>
                  Sass has mixins as well as functions. Sass functions are similar to JS functions.</p>
                  <p>
                  They can accept arguments and return a value.</p>
                  Ex.:
                  
                  <code>
                  @function divide($a, $b){
                    @return $a / $b;
                  }
                  
                  @function multiply($a,b){
                    @return $a * $b;
                  }
                  
                  div{
                  height: multiply((divide(60, 2)), 1px);
                  }
                  </code>
                  
                  <h2>Partials and Import</h2>
                  <p>
                  <strong>Partials</strong> in Sass are separate files containing Sass code that make the code modular. It allows to have separate Sass files for different components.
                  <br /><br />
                  For example, building a more elaborate math library for Sass off of the example above could be separated out.
                  <br /><br />
                  A partial's name always starts with an underscore. Use @import to import a partial into another Sass file. For example, importing the _header.scss file into main.scss:
                  </p>
                  
                  <code>
                  // main.scss
                  @import 'header'; /*the partial being imported doesn't need to use the _ or .scss when importing */
                  </code>
                  <p>
                  *Unlike CSS imports, Sass imports don't send another HTTP request for fetching the partial since <strong>all the imports are placed into a single CSS file during compilation.</strong>
                  </p>
                  
                  *<h2>
                  Inheritance/Extend</h2>
                  
                  <p>
                  You can share CSS properties from one selector to another using the <span class="code-inline>@extend</span> directive. <br /><br />
                  </p>
                  <p> 
                  
                  Generally, for inheritance you use <strong>placeholder classes</strong> which starts with a <span class="inline-code">%</span>. Using placeholder classes allow you to only print something in the compiled CSS once it's extended. <br /><br />
                  </p>
                  <p>
                  *<strong>Placeholder selector (%)</strong> - similar to the class selector in CSS, which uses <span class="inline-code">.</span>, but have the additional property that <strong>they will not show up in the generated CSS; only the selectors that extend them will be included in the output.</strong>
                  <br /><br />
                  This helps keep CSS very DRY.
                  <br /><br />
                  
                  In the following:</p>
                  <code>
                  %message-shared{
                    border: 1px solid #ccc;
                    padding: 10px;
                    color: #333;
                  }
                  
                  %equal-heights{
                    display: flex;
                    flex-wrap: wrap;
                    //this will never print because @equal-heights never ends up being extended
                  }
                  
                  .message{
                    @extend %message-shared;
                  }
                  
                  .success{
                    @extend %message-shared;
                    border-color: green;
                  }
                  
                  .error{
                    @extend %message-shared;
                    border-color: red;
                  }
                  
                  .warning{
                    @extend %message-shared;
                    border-color: yellow;
                  }
                  </code>
                  <p>
                  The above code tells .message, .success, .error, and .warning to behave just like <span class="inline-code">%message-shared </span>. <br />
                  </p>
                  
                  <p>
                  So anywhere <span class="inline-code">%message-shared</span> shows up, .message, .success, .error & .warning will too. <br />
                  </p>
                  <p>
                  The magic then happens in the compiled CSS, where each class gets the same CSS properties as <span class="inline-code">%message-shared</span>. <br />
                  </p>
                  <p>
                  This helps you to <strong>avoid having to write multiple class names on HTML elements</strong>.
                  </p>
                  
                  <h2>Ampersand (&) Operator</h2>
                  <p>
                  If you had to style the following HTML:
                  </p>
                  <code>
                  button class="btn btn—green" Hello World /button
                  </code>
                  <p>
                  Instead of doing this:
                  </p>
                  <code>
                  .btn{
                    display: block;
                    padding: 5px 8px;
                  }
                  
                  .btn—green{
                    background-color: green;
                  }
                  
                  .btn: hover{
                    background-color: transparent
                  }
                  </code>
                  <p>
                  It can instead be written as:
                  </p>
                  <code>
                  .btn{
                    display: inline-block;
                    padding 5px 8px;
                  
                    &—green{
                    background-color: green;
                    }
                  
                    &:hover{
                    background-color: transparent
                    }
                  }
                  </code>
                  <p>
                  This allows you to nest selectors that share the same name, and during compile-time the & operator is replaced by the enclosing selector name.
                  </p>

                                    
                  <h2>Compile Sass Code to CSS
                  </h2>
                  <p>
                  
                  2 main options: <br /><br />
                  
                  
                  1. Gulp automate <br />
                  2. node-sass - a sass compiler.
                  </p>
                  
                  1. npm install node-sass —save-dev<br />
                  2. Create npm script to compile Sass code into CSS code - add script inside the script section of package.json:
                  "compile-sass": "node-sass sass/main.scss css/style.css —watch" <br />
                  3. Run using <span class="inline-code">npm run compile-sass</span>  <br />
                  
                  <h2>Concepts
                  </h2>
                  
                  @mixin directive  <br />
                  @include directive  <br />
                  @import directive  <br />
                  @extend directive  <br />
                  pass arguments to mixins  <br />
                  sass variables - declared with $  <br />
                  placeholder selectors - use %, similar to . css selector  <br /><br />

                  
                  
                  
                  
                  
              </article>
              </section>      


          <section class="main-section" id="Javascript">
            <header>Javascript Fundamentals</header>
            <article>

              <h2 id="jsEditions">JS Editions: </h2>
                <li> 5th Edition (2009) </li>
                <li> 6th Edition - ECMAScript 2015 </li>
                <li> 7th Edition - ECMAScript 2016 </li>
                <li> 8th Edition - ECMAScript 2017 </li>
                <li> 9th Edition - ECMAScript 2018 </li>
                <li> ES.Next - Dynamic name referring to whatever the next version is at the time of writing. <br />
                (ESNext features are actually referred to as proposals since they haven't happened yet.)

                <h2 id="jsCallback">Callback Functions:</h2>
                  <b>Callback</b> - A function which is:
                    <li>Passed as an ARGUMENT to another function, and </li>
                    <li>Is invoked after some kind of event (so callback is the child function of a parent almost but not bound to scope) </li>
                    
                  <p>  A callback is a function you provide to another piece of code, allowing it to be called by that code. To "call back" means to pass a function to other function or other 			  code. So it's passed into another function as an argument, which is then invoked inside the "outer function" to complete something. And once a callback function's parent function completes, the function passed as an argument is then called.</p>
                  <p> Callback functions are also called higher-order functions.</p>
                    
                    
                  Example of a callback:
                  <code>
                    XMLHttpRequest.onreadystatechange = callback;
                  </code>
                    This is just a function passed almost like the parameters for another function, that is then also called when that "parent function" is triggered. So you run the parent one and it calls back whatever then gets filled in.
                    
                    <h2 id="jsClosure">Closures:</h2>

                    <p>Closure - Any function where you are using a variable(parameter) outside the scope. </p>

                    <p><b>Closures</b> are important because: <br />
                    1. A scope is at the function level, not the block level<br />
                    2. Much of what you do in hs is async / event-driven<br />
                    3. They make event-driven code a lot easier to write
                    <p>
                    A closure is an inner function that has access to the outer (enclosing) function's variables and parameters.
                    The inner function then has access to the outer function's variables and parameters.
                    Even after the outer function has returned, the inner function still has access to the outer function's variables.
                    So, you can call the inner function later in your program.
                    </p>
                    <p>
                    A closure is a function that returns a function - so it's the whole thing and not just the inner function being the closure.
                    The function that is returned (the inner function) is created inside the called function (the outer).
                    Due to the scoping rules we’ve seen, the inner has access to the variables and arguments of the outer. <br /><br />
                    Functions created in a particular scope retain access to vars in the scope even if they are called outside of it, because there's 1. create and 2. call with functions.<br /><br />
                    Example of a closure:
                    </p>
                    <code>
                    function one(a, b){
                      function two(){
                      return "foo";
                      }
                      var variable;
                      return variable;
                    }
                    two();
                    </code>
                    <p>
                    So, even though two is called outside of the function one because it's created inside of one, it has access to one's scope.<br />
                    two() can access one's params (a and b), and var variable / the return statement since it's in one's body and therefore scope.
                    </p>

                    <p>Closures are possible because Javascript uses lexical scoping.</p>

                    <strong>Lexical scope</strong> - The outer scope of a function which is defined inside a closure.<br /><br />

                    Example of a closure:

                    <code>
                        var passed = 3;
                        var addTo = function(){
                          var inner = 2;
                          return passed + inner; 
                        }; /* This is a closure - var passed is available inside the function, 
                        but var inner is not available outside the function */</code>

                    <h2 id="jsCross">Cross-Browser Issues:</h2>

                    <p>JS in different browsers:</p>
                    <p>This originates in the 90s when there were IE and Netscape - Netscape had JS and IE had Jscript and VBScript
                    Things like jQuery were created to abstract away differences in brower implementations</p>
                    
                    <p>JS compatibility issues happen when:</p>
                    <li>Bad code in regards to feature detection browser sniffing etc blocks browsers from rnnng otherwise fine code</li>
                    <li>When new features are used in code but not supported in older browsers.</li>
                    
                    
                    <h2 id="jsCurry">Currying:</h2>

                    <p>
                    <b>Currying </b>provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument.
                    An example would be situations where some analytical techniques can only be applied to functions with a single argument.
                    In theoretical work it provides a way to study functions with multiple arguments in a simpler theoretical model that provides only one argument.</p>
                    
                    <p>Currying can equal returning a bunch of things or also like how php template tags let you "repeat" things easier than with html across pages.</p>
                    
                    <strong>Currying - </strong> transforming a function that takes multiple parameters, into the same function with less parameters. <br /><br />

                    This "curried effect" is achieved by binding some of the args to the first function invoke, so those values are fixed for the next invocation.
                    <br /><br />
                    
                    Translating a function that takes multiple arguments, into a sequence of functions, each with a single argument.<br /><br />
                    
                    Currying is like prefilling certain parts of a function for code reuse - useful in event handling. <br /><br />
                    
                    Currying is a pattern that's not native to js, so you can write a currier that can transform any given function to a curried version of itself:
                    <code>
                    var currier = function(a){
                      var args = Array.prototype.slice.call(arguments, 1);
                      return function(){
                        return fn.apply(this, args.concat(
                          Array.prototype.slice.call(arguments, 0)));
                      };
                    };
                
                    </code>
                    <br />
                    Curried function example:
                    <code>
                    var babyAnimals = function(a){
                      return function(b){
                        var result = 'i love '.concat(a).concat(' and ').concat(b);
                        return result;
                      }
                    
                    }
                    </code>


                    <h2 id="jsDebug">Debugging:</h2>
                    <p>Can be done via:</p>
                    
                    <li>Console in browser</li>
                    <li>JS Validator AKA <b></b>linting</b> - Checks to make sure code is valid and follows syntax of language (LINTING)</li>
                    <li>JS Debugging app <a href="http://www.hacksrus.com/~ginda/venkman/" target="blank">hacksrus.com/~ginda/venkman/</a></li><br />
                    
                    <p>Linting can go through source code and find:</p>
                    <li>Non-adherence to coding standards</li>
                    <li>Pinpointing possible logical errors in program</li>
                    
                    <p>
                    <b>ESLint</b> -
                    Javascript linter that requires node.js<br />
                    <b>JSHint</b> - 
                    Online linter<br />
                    </p>
                    
                    <h2 id="jsFeature">Feature Detection:</h2>

                    <p><b>Feature detection</b> - Working out whether a browser supports a certain block of code, and running different code dependent on whether it does or doesn't so a browser can always provide a working experience rather than crashing/erroring in some browsers.<br />
                    
                    An example would be testing flexbox support in a browser. <br />
                                            
                    Modernizr is the industry standard for feature detection tests. Feature detection is made easy in CSS with the @supports @ rule.
                    </p>
                    <p>
                    Do not confuse feature detection with <b>browser sniffing</b>: <br /><br />
                    feature detection = good<br />
                    browser sniffing = bad<br /><br />
                    
                    Browser sniffing is bad because it's an error prone process - the only real use is fixing a bug for a very specific version of a particular browser.
                    </p>
                    
                    Example of feature detection:
                    <code>
                    if("geolocation" in navigator){
                      navigator.geolocation.getCurrentPosition(etc…)
                      //show location on a map
                    } else{
                      //give user choice of static maps instead
                    };
                    </code>



                    <h2 id="jsFetch">Fetch API</h2>

                      The <strong>Fetch API</strong> will be familiar with anyone who has used XMLHttpRequest. This API provides a more powerful and flexible feature set.
                      <br /><br />
                      Fetch provides a generic definition of <span class="inline-code">Request</span> and <span class="inline-code">Response</span> objects, as well as other things involved with network requests. <br /><br />
                      These objects will be available for many things, including: <br />
                      <li>Service workers</li>
                      <li>Cache API</li>
                      <li>Any other time you''re handling or modifying requests and responses</li>
                      <li>Any kind of use case that might require you to generate your own responses programmatically</li>
                      <br />
                      
                      The <span class="inline-code">fetch()</span> method takes <strong>one mandatory argument</strong>, which is the <strong>path to the resource</strong> you want to fetch. <br />
                      It returns a <span class="inline-code">Promise</span> <strong>that resolves to the <span class="inline-code">Response</span> to that request, whether it's successful or not. 
                      </strong>
                      <br />
                      You can also pass in an <span class="inline-code">init</span> options object as the second argument optionally. <br />
                      
                      Once a <span class="inline-code">Response</span> is received, many methods are available for defining what the <span class="inline-code">body</span> content is and how it should be handled. <br />
                      














                    

                    <h2 id="jsGet">Get and Set</h2>
                    <p>Get: 
                        <br />
                        <li>Used to access the values of a variable</li>
                        <li>An Accessor - used to access</li>
                        </p>
                        
                        <p>Set:
                        <br />
                        <li>Used to set the values of a variable</li>
                        <li>A Mutator - used to change</li>
                        </p>
            

                        <h3>Disadvantages of Getters and Setters</h3>

                        <h3>Notes</h3>
                        <li>Getters and setters give control over how internal state can be modified</li>
                        <li>Mutator method - Method used to control changes to a var. (a.k.a. setter method)</li>
                        
                  <h2 id="jsHoist">Hoisting:</h2>

                  <p>Variables declared w/ var are “hoisted” to “top” scope as in they can’t be declared twice I think. <br />
                  Basically why when you have an if else statement, you can’t declare the same variable twice using “var” or it will get an “___ already defined” error. <br />
                  Technically you could have an if/else statement referencing “action” and define “var action” after them.<br />
                  </p>
                    
              <h2 id="jsIIFE">I.I.F.E.:</h2>

                <b>Immediately Invoked Function Expression</b> - Allows you to control variable scope - variables inside an IIFE aren’t available outside it. It's a function that runs as soon as its defined.

              <h2 id="jsImage">Image Maps:</h2>

                You can make image maps in Javascript: <a href="https://www.tutorialspoint.com/javascript/javascript_image_map.htm">https://www.tutorialspoint.com/javascript/javascript_image_map.htm</a> <br />
                An image map = clickable areas. You can also define coordinates.

              <h2 id="jsNull">Null vs. Undefined vs. NaN:</h2>
                <p>
                Null = Can be assigned to a variable as a representation of no value. <br />
                Undefined = A variable that has not been assigned a value. <br /> <br />

                typeof null = object<br />

                typeof undefined = it's already a type - undefined<br /><br />

                So, undefined is a type itself, while null is an object you can interact with ("empty").<br />
                So null can be some empty placeholder thing, ex.: </p>

                <code>

                null + 3
                = 3

                </code>
                <br />
                Whereas with undefined:
                <code>
                undefined + 3
                = undefined or NaN
                </code>
                <p>
                If arithmetic makes no sense, JS yields special Numbers:</p>
                <code>
                Infinity or NaN(Not a Number).
                console.log(5 / 0);
                //->Infinity
                </code>

              <h2 id="jsPropVs">Properties vs. Methods:</h2>

              <li>Data is represented as PROPERTIES of the object, and
              <li>Behavior is represented as the methods</li>

              <p>
              Method: <br />
              In OOP, it's a procedure associated with a. A message (almost like an HTTP header) and b. an Object.
              </p>
              <p>
              That's what an object is and that's what object oriented is: everything including DOM elements has their a. properties (if available) and b. methods (if available). So all the object.thing1.thing2 can be applied to everything.
              </p>
              <p>
              Ex.: A Window object would have methods such as open and close. <br /> 
              That's what it means by procedural is the method is a procedure to be carried out as a message to the object to enact something, while its state is a property.
              </p>
              <p>
              Open and close i.e. procedures i.e. imperatives are methods or things you can perform on/with the object.
              State or value in an array or key-value pair or even like location are properties.
              </p><p>
              Methods are like miniature algorithms, while properties are characteristics.
              Methods allow you to interact with the properties of an object.
              This is also what people mean when they say encapsulation.
              </p><p>
              Methods are actions that can be performed on objects.
              The name:values pairs (in JavaScript objects) are called properties.
              </p>
            <h2 id="jsPrototype">Prototypes:</h2>
              <p>
              Javascript is multi-paradigm:  <br />
              1. OOP with prototypal inheritance <br />
              2. Functional programming <br />
              3. Imperative/procedural programming <br />
              </p>
              <p>
              Every JS object has a prototype. The prototype is also an object. All JS objects inherit their properties and methods from their prototype. The prototype pattern creates new objects, but rather than creating non-initialized objects, it returns objects that are initialized w the values copied from the prototype object.
              </p>

              So there's: <br /><br />

              1. The prototype (sample)<br />
              2. The clone<br />
              3. The creation of that clone<br /><br />
              Ex.: <br />
              1. function CustomerPrototype(proto){} - //the prototype <br />
              2. function Customer(first, last, something){} - //The cloned objects being created <br />
              3. function run(){} - //creates new object by asking prototype to clone itself <br />
              <br />
              <h3>Rules:</h3>
              <li>Objects created with new Object() inherit from a prototype called Object.prototype.</li>
              <li>Object.protoype is at the top of the chain - so all objects inherit from this.</li>
              <li>When you ask for a property of an object, JS looks for that property - if it doesnt find it, it follows the prototype chain until it finds the property, or returns undefined.</li><br />

                <h3>Prototype Example</h3>
                <code>

                    var prototypeof = {firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};
                    var objwithprototype = Object.create(prototypeof);
                    
                    Object.getPrototypeOf(objwithprototype);
                    
                    console.log(Object.getPrototypeOf(objwithprototype));
                    console.log(prototypeof.isPrototypeOf(objwithprototype));
                    
                    var test= [];
                    Object.assign(test, prototypeof);
                    console.log(test);
                    console.log(Object.entries(test));
                    
                    console.log(typeof test);</code>
                  <br />
              <h3>Terms:</h3>

              <strong>mutations</strong> - changing or affecting a source element; a mutation is a side effect. 
              <br />

              Examples of mutable versus immutable methods: <br /><br />

              <span class="inline-code">Array.prototype.push</span> (source element mutated)
              <span class="inline-code">Array/prototype.unshift</span>  (source element mutated)
              <span class="inline-code">Array.prototype.concat</span>  (immutable)
              <span class="inline-code">Spread Operator (…)</span>  (immutable)
              <br /><br />
              <span class="inline-code">Array.prototype.push</span> <strong>
              does not return</strong> a copy of the array it's used on; rather, it <strong>mutates the original array</strong> by adding a new element and returning the <span class="inline-code">length</span> property of the object upon which the method's called.
              <br /><br />
              <span class="inline-code">concat</span> does not mutate - the goal with mutations versus immutables is<strong>keeping the source array untouched</strong> (to prevent side effects).

              <strong>shallow copies vs deep clones</strong> - use <span class="inline-code">cloneDeep</span> if the elements of the source array are other arrays or objects that need to be kept untouched. Deep cloning, however, is very expensive in terms of performance.














              <b>new</b> keyword - 
              new constructor[(arguments)]<br />
              <b>constructor</b> - Special method for creating an object within a class.<br /><br />
              So JS DOES have classes but they were only introduced in ECMA 2015 ( so constructors are kind of new with JS)<br />
              class-based - constructors & factory method pattern.<br /><br />
              <strong>prototypal</strong> - prototype design pattern. Each instance of an object created from the prototype is just a copy.<br />

            <h2 id="jsPrototypalVs">Prototypal vs. Classical:</h2>

              <b>Classical inheritance</b> - Aka class inheritance "instances" inherit from classes, like a blueprint (PHP). <br />
              These are usually instantiated via constructor functions using the new keyword. (PHP) <br />
              Class inheritance may or may not use the "class" keyword. <br /><br />

              <b>Prototypal inheritance</b> - Aka "instances" inherit directly from other objects aka "prototypes".<br />
              They're usually instantiated via "factory functions" or ex. object.create().<br />
              Prototypal inheritance is simpler and more flexible than class inheritance.<br />
              Prototypal inheritance = objects WITHOUT CLASSES, OLOO. <br />

            <h2 id="jsPure">Pure Functions</h2>

              A function where the return value is only determined by its input values w/o side-effects. <br />
              Ex.: math.cos(x). Computing this does not change "x" - doesn't ask for input or change state. <br />
              So pure = stateless for the most part.

            <h2 id="jsRecursion">Recursion</h2>
              <p>
              <b>Recursion</b> - A function invoking (calling) itself again and again until it reaches the final return condition at which point it returns the final value.<br /><br />
              Each time the function is called, a new local scope is created.
              
              </p>
              <h2 id="jsReturn">Return Statements</h2>
              <p>
              <b>Return</b> - a and b are a function’s parameters, and the value it returns is signified by the return keyword. 
              <li>The return keyword also stops execution of the code in the function; nothing after it will be run.</li>
              <li>Functions without a return, aka “returning nothing”, will end up being “undefined”. Every function is going to return “Undefined” UNLESS you give it a return value. </li>
              <li>A function's return value can be passed to another function as a parameter.</li>
              </p>            

              <h2 id="jsScope">Scope</h2>       
                A variable’s <strong>scope</strong> is the portion of code where it’s visible.
                newline
                It's important to understand that a <strong>block (identified by a pair of curly braces) does not define a
                new scope</strong>. A new scope is only created when a function is created, because <span class="inline-code">var</span> does not have block scope, but function scope.
                <br /><br />

                <strong>block scope</strong> - Block = set of curly braces, ex.:
                <code>
                if(x > y){
                ...
                }
                </code>

            <h2 id="jsSelectors">Selectors</h2> 

              Use a <b>selector</b> to grab an element, ex.:
              <code>
              var numOne = document.getElementById(“num-one”);</code>

            <h2 id="jsSide">Side Effects:</h2>
              <p>
              <b>side-effects</b> - Any app state change that is observable (aka opposite of pure functions). Side effects are avoided in functional programming. <br /> <br />
              Ex.: Writing to a file, triggering any external process, logging to the console.
              </p>

            <h2 id="jsRegex">Regex</h2>
              <p>
                  .replace(/\D/g, '') <br />              
                  <a href="https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285" target="_blank">Regex cheat sheet</a>
              </p>

            <h2 id="jsState">State</h2>
              <p>
              <b>State</b> - Information about something held in memory. The set values that something's attributes have at any given moment (things saved to memory).<br /><br />
              Ex.: 10, or "HELLO"= By itself is stateless - does not represent any state. (aka pure values)
              <br />
              There's a state when these "pure values" are associated to some kind of entities, for ex. objects. <br /><br />
              Ex.:<br />
              <code>
              var car = ("color", "blue"); //properties of "car"
              </code>
              <br /> Since car has properties it has a state.
              It's associated to an "entity" (i.e. class/object I think), but ALSO to a point in time.
              So if today car = color, blue but tomorrow it's color, black, then black is the new state of that car object.<br /><br />Properties = states.<br />
              When the properties change, the states change.<br /><br />


              <b>Shared state</b> - aka shared mutability. Can be bad because code isn't like containerized or separated or whatever, so it can be a mess.

              </p>


            <h2 id="jsThis">this Operator</h2>

              Ex.:<br /><br />

              "John is running fast because <b>he</b> is trying to catch the train".<br /><br />

              The this operator acts like the pronoun "he" - so we don't have to say "John is running fast because John is trying to catch the train".
              <br /><br />

              Ex.:

              <code>
              var person = {
                firstName: "Bob",
                lastName: "Logg",
                function fullName(){
                console.log(this.firstName + this.lastName);
                console.log(person.firstName + person.Lastname);
                }
              }</code>

              In this instance, this.firstName is the same as saying person.FirstName, so it just lets you	reference it without being redundant.

              This is used because there could be a global var w the same name as the one you're interacting with (ex. global person and var person).
              <br /><br />
              Ex.:
              <code>
              $("button").click(function (event){
                console.log($ (this).prop ("name"));
              this will have a val of ($("button"))
              });</code>

              So this can be used in syntax where you need to access an function's props within the function itself ex.:
              <code>
              function showFullName(){
                console.log(this.firstName + this.LastName);
              }</code>


            <h2 id="jsTypes">Types</h2>

              <h3>There are 7 total data types:</h3>

              Primitive types: <br />
              <li>Boolean</li>
              <li>Null</li>
              <li>Undefined</li>
              <li>Number</li>
              <li>String</li>
              <li>Symbol(new in ES6)</li>
              <br />

              Non-primitive types: <br />
              <li>Object</li><br />

              All types except the non-primitive type, object, define immutable values, incapable of being changed.
              <br /><br />
              Function = primitive type<br />
              Object = complex type<br /><br />

              Every "thing" in JS - including primitive data types and other things - Ex.: <br /> 
              <li>Date Object</li>
              <li>String Object</li>
              <li>Number Object</li>
              <li>Math Object</li>
              <li>Array Object</li>
              <li>Boolean Object</li>
              <li>Error Object</li>
              <li>RegExp Object</li>
              <br />
              These are all OBJECTS - as in they have specific PROPERTIES and then METHODS. So Math is an object as well.
              <br />
              <h3>Terms:</h3>

              <b>Polymorphism</b> - A type whose operations can be applied to values of some other type or types. (ex. int and variables) <br />

              <b>Subtypes</b> - Ex. cat is a subtype of animal. So, an expression of type cat can be used anywhere that type animal is used. <br />

              <b>Type Theory</b> - When with math they write f: X —> Y, X is the old type, Y is the new type being built from the old, and the arrod is a type constructor that i guess designates this.

            <h2 id="jsVoid">Void Operator </h2>

              <strong>Void</strong>: 
              
              <li>Is an operator that's used to return an undefined value so the browser will not be able to load a new page.</li>
              
              <li>Is used in an immediately-invoked function expression</li>
              
              <li>Can be used to force the function keyword to be treated as an expression instead of a declaration</li>
             
            <h2 id="jsTips">Tips</h2>


              * Chain methods together when possible. <br /><br />
              * Map with arrow function <br /><br />
              * Use . notation to access a property <br /><br />
              * Object syntax (const object = {}; ) <br /><br />
              * Objects can contain other objects <br /><br />

              * In JS, an empty string returns a false <br /><br />
              event object = e as parameter  <br /><br />
              DOM operations tend to be slow - which is why the Virtual DOM (diffing vs. real DOM - only updating what's needed a.k.a. computing minimal DOM  operations) is important.  <br /><br />

              * Properties are accessed as Obj.property, methods are Obj.method().  <br /><br />

              * In loops, i is a loop counter variable; can be thought of as "index"  <br /><br />

              * this.attributes["data-img"] is a different accessor, but same way as saying this.attributes.data-img, but since that's bad syntax you want to use the array accessor instead. <br /><br />

              * modular = isolated = don't use globals typically <br /><br />

              <h4>map vs for loop </h4>
              
              Both have their positives:
              <br /><br />
              
              Most developers will understand a for loop and know what you're doing right away. A for loop can be thought of as easier to read.
              <br /><br />
              
              <span class="inline-code">map()</span> 
              can save you 2 or 3 lines of code.
              <br /><br />
              
              As far as performance goes, <span class="inline-code">map() </span> is built internally with something similar to a for loop, and there might be a few milliseconds of difference when it comes to performance speeds through large enough iterations but that's it.
              
              Map and reduce both emphasize <strong>readability</strong> and <strong>maintainability</strong>. <br /><br />
              
              
              <span class="inline-code">forEach()</span>  - executes a provided function (a <strong>callback</strong>) once for each element, but doesn't return anything.
              <br />
              <span class="inline-code">map()</span> - executes a provided function (callback) once for each array element, and <strong>creates a new array</strong> with the results of this execution.
              
              
              <h4>Detect client's browser name</h4>
              <span class="inline-code">navigator.appName</span> 
              <br />
              
              <h4>Find the number with the highest value of x and y</h4>
              <span class="inline-code">Math.max(x,y)</span>
              <br />
              
              <h4>every() vs filter()</h4>
              
              filter() creates an array of all the elements matching the condition in the callback, while every() returns true (boolean) if every element in the array matches the condition in the callback. <br />
              
              <h4>Function Calls</h4>
              <strong>Call</strong>ing a function literally just means saying <span class="inline-code">myFunction()</span>.
              <br />
              
              <h4>for vs forEach</h4>
              
              <code>
              //functionally equivalent
              
              for (var i = 0; i < arr.length; i++) {
                console.log('Element', i, 'is', arr[i]));
              }
              
              arr.forEach(function(element, i) {
                console.log('Element', i, 'is', element);
              });
              </code>
              *forEach only works on arrays, however. Don't use if you need to count for example.
              
              Accumulator vs. Parameter - usually used interchangeably; however, a parameter is something given to a function (declaration, definition or prototype), and an argument is something actually passed when calling that function. Ex.:
              <code>
              var test = function(a,b){
                console.log(a); //both print 10
                console.log(arguments[0]));
              }
              test(10,20);
              </code>
              
              Unfortunately, sometimes algorithm knowledged is just based on knowing quirks: like, there's an array method for reverse, but not for a string. So to reverse a string you have to split it into an array, reverse it, then join it again.
              
              <h4>Using apply</h4>
              .apply - It's common to use apply where you want to use the elements of an array as arguments to a function. <br />
              
              <h4>null</h4>
              null = can be used as a placeholder (for a function's arguments):
              <code>
              function myFunction (a, b, c, d){}
              var args = [0, 1, 2, 3];
              myFunction.apply(null, args); //apply the array args as arguments to the function myFunction
              </code>                            
              
              <h4>Arguments object</h4>
              Arguments object - an array-like object accessible inside all functions, containing the values of the args passed to that function. Array-like means <span class="inline-code">arguments</span> has a <span class="inline-code">length</span> property/properties indeed from zero, but doesn't have Array's built-in methods like forEach() and map().
              <br />
              
              <h4>Change content of html element</h4>
              <code>
              p id="demo" This is a demonstration. /p
              document.getElementById("demo").innerHTML = "Hello World!";
              </code>
                            
              <h4>Return last item in array</h4>
              <code>
              return array.length-1;
              </code>
              
              <h4>Find the largest number in an array</h4>
              <code>
              function findLargest(){
              return Math.max(…arr) //spreads array into values so it can be operated on I think
              }
              </code>
              
              <h4>Use dot notation to access a property</h4>
              

            </article>
            </section>

          <section class="main-section" id="jsDoc">
            <header>Javascript Documentation</header>
            <article> 
            <h2 id="js2String">Strings</h2>
            <h3>String Methods</h3>
              
              *Methods and properties are accessed the same way, ex.: <br />
              str.indexOf() is a method, str.length is a property. <br /><br />
              
              <span class="inline-code">charAt()</span> - returns character at specified position of string, ex.: 
              <code>
              var str = "Hello World";
              var strResult = str.charAt(3);
              </code><br />
              
              
              <span class="inline-code">concat()</span> - join two or more strings. Ex.:
              <code>
              var str1 = "Hello ";
              var str2 = "world,";
              var str3 = " have a nice day";
              var result = str1.concat(str2, str3);
              </code><br />
              
              <span class="inline-code">endsWith()</span> - checks if a string ends with the characters of a specified string, ex.:
              <code>
              var str = "Hello world, welcome to the universe.";
              var strCheck = str.endsWith("universe.");
              </code><br />
              
              <span class="inline-code">includes()</span> - check if a string includes specified characters, ex.:
              <code>
              var str = "Hello World, welcome to the universe.";
              var strResult = str.includes("welcome);
              </code><br />
              
              <span class="inline-code">indexOf()</span> - returns the position of the first occurence of a specified value in a string. Returns <span class="inline-code">-1</span> if the value to search never occurs. <br />
              Ex.:
              <code>
              var str = "Hello World, welcome to the universe.";
              var strResult = str.indexOf( "welcome"); //returns 13
              </code><br />
              
              <span class="inline-code">lastIndexOf()</span> - returns the position of the last occurence of a specified value in a string.
              
              <span class="inline-code">match()</span> - searches a string for a match against a regex; returns the match(es) as an <strong>Array</strong> object. Ex.:
              <code>
              var str = "The rain in SPAIN stays mainly in the plain";
              var res = str.match(/ain/g);
              </code><br />
              
              <span class="inline-code">repeat()</span> - returns a new string with <strong>a specified number of copies</strong> of the string it's called on, ex.:
              <code>
              var str = "Hello World";
              str.repeat(2);
              </code><br />
              
              <span class="inline-code">replace()</span> - a. searches a string for a specified value or regex, and b. returns a new string where the values are replaced. 
              <code>
              var str = "Hello World";
              var strNew = strReplace("World", "Universe"); //specify word to be replaced
              </code><br />
              
              <span class="inline-code">search()</span> - searches a string for a specified value and returns the position of the match. <br /><br />
              
              <strong><span class="inline-code">slice()</span></strong> - extracts part of a string, returns the extracted part in a new string. <br />
              Use the start and end parameters to specify the part of the string to extract. <br />
              Syntax: <span class="inline-code">string.slice(start, end)</span> <br /><br />
              
              
              <span class="inline-code">split()</span> - split a <strong>string</strong> into <strong>an array of substrings</strong>, then returns the new array.
              <br />
              *If an empty string ("") is used as the separator, the string is split between each character. <br />
              Ex.:
              <code>
              var str = "How are you today?";
              str.split(" "); //returns How,are,you,doing,today?
              </code><br />
              
              <span class="inline-code">startsWith()</span> - determines whether a string begins with the characters of a specified string; returns a boolean. Ex.:
              <code>
              var str = "Hello World";
              var strStart = str.startsWith("Hello");
              </code><br />
              
              <span class="inline-code">substr()</span> - literally the same as slice().<br /><br />
              <span class="inline-code">substring()</span> - literally the same as slice(). <br /><br />
              
              <span class="inline-code">toLowerCase()</span> - converts a string to lowercase letters. <br /><br />
              
              <span class="inline-code">toString()</span> - returns the value of a string object. Ex.:
              <code>
              var str = "Hello World";
              var result = str.toString(); //returns Hello World
              </code><br />
              
              <span class="inline-code">toUpperCase()</span> - converts a string to uppercase letters. <br /><br />
              
              <span class="inline-code">trim()</span> - removes whitespace from both sides of a string. <br /><br />
              
              <span class="inline-code">valueOf()</span> - returns the primitive value of a String object (not typically used). <br /><br />
              
              
            <h3>String Properties</h3>
              
              <span class="inline-code">constructor</span> property - returns a reference to the function that created the instance object. <br /><br />	
              
              <span class="inline-code">length</span> property - returns length of a string in a number of characters.
              <br /><br />
              
              <span class="inline-code">Prototype</span> property - use to add a new property to all objects of a given type (add new properties and methods to existing object types, like "employee"), ex.:
              <code>
              function employee(name, jobtitle, born) {
                this.name = name;
                this.jobtitle = jobtitle;
              }
              employee.prototype.salary = 2000l
              </code><br />

            <h2 id="js2Array">Arrays</h2>
            <h3>Array Methods</h3>
            
              <span class="inline-code">concat()</span> - join two or more arrays.<br /><br />
              
              <span class="inline-code">copyWithin()</span> - copy the first two array elements, and replace the last two array elements with them.<br /><br />
              
              
              <span class="inline-code">entries()</span> - create an <strong>Array Iterator</strong> object with key-value pairs for each item. Ex.:
              
              <code>
              var fruits = ["Banana", "Orange", "Apple"];
              fruit.entries();
              /*prints out:
              [0, "Banana"]
              [1, "Orange"]
              [2, "Apple"]
              </code><br />
              
              <span class="inline-code">every()</span> - checks if all elements in an array pass a test, provided as a function. Ex.:
              
              <code>
              var ages = [32, 33, 16, 40];
              
              const checkAdult = (age) => { //check if every element in the array has a value of 18 or more
                return age >= 18;
              };
              ages.every(checkAdult);
              </code><br />
              
              <span class="inline-code">fill()</span> - fill all array elements with a static value, ex.:
              <code>
              var fruits = ["Bananas", "Oranges", "Apples"];
              fruits.fill("kiwi");
              //returns kiwi kiwi kiwi
              </code><br />
              
              <strong><span class="inline-code">filter()</span></strong> creates a new array with all elements that pass whatever test is implemented by the provided function (callback). So if a condition is true for a value being filtered, it gets put in the array Ex.:
              <code>
              const isBigEnough = (element) {
                return element >= 10;
              }//the callback function with the condition to be tested
              var filtered = [12, 5, 9, 130, 44].filter(isBigEnough);
              
              </code><br />

              Ex.:

              <code>
              var words = ['word', 'longword' 'longerword', 'longestword'];
              
              var filtering = (words.length > 5);
              var result = words.filter(filtering);
              </code>



              
              <span class="inline-code">find()</span> - returns the value of the first element in an array that passes a given test (callback) Ex.:
              <code>
              var ages = [3, 10, 18, 20];
              
              var checkAdult = (age)  => {
                return age >= 18;
              };
              ages.find(checkAdult);
              </code><br />
              
              <span class="inline-code">findIndex()</span> - almost the same as find(), but returns the index of that first value that passes the test instead of returning the actual value itself.<br /><br />
              
              
              *<span class="inline-code">forEach()</span> - calls a provided function once for each element in an array, in order (not unlike for loop).<br /><br />
              
              
              **<span class="inline-code">from()</span> converts either a. any object with a length property, or b. an iterable object into an Array (ex. a string). Example:
              <code>
              var myArr = Array.from(""ABCDEFG);
              //returns array ["A", "B", "C", "D", "E", "F", "G"]
              </code><br />
              
              <span class="inline-code">includes()</span> - check if an array includes a given value, returns boolean.
              <br /><br />
              
              <span class="inline-code">indexOf()</span> - searches array for specified item, returns its position. <br />
              Syntax: <span class="inline-code">array.indexOf(item, start)</span> 
              <br /><br />
              
              <span class="inline-code">isArray()</span> - check whether an object is an array. Syntax: <span class="inline-code">Array.isArray(obj)</span> 
              <br /><br />
              
              <span class="inline-code">join()</span> - joins the elements of an array <strong>into a string</strong>, and returns the string. <br />
              The elements will be seaparated by a specified separator (optional); the default separator is a comma. Syntax: <span class="inline-code">array.join(separator)</span> <br />
              Ex.:
              <code>
              var fruits = ["Bananas", "Oranges", "Apples"];
              var combine = fruits.join();
              //outputs Bananas,Oranges,Apples - comma is separator by default
              </code><br />
              
              <span class="inline-code">keys()</span> -returns an array of a given object's <strong>property names</strong>, in the same order you'd get with a normal loop, ex.:
              <code>
              const object1 = {
                a: 'string',
                b: 42,
                c: false
              };//so it returns an object's keys, in order
              </code><br />
              
              <span class="inline-code">lastIndexOf()</span> - searches array for specified item, returns its position.
              <br /><br />
              
              <span class="inline-code">map()</span> creates an output array after calling a function for every input array element. Ex.:
              <code>
              var numbers = [4, 9, 16, 25];
              const myFunction = () => {
                numbers.map[Math.sqrt];
              };
              </code><br />
              
              <span class="inline-code">pop()</span> - removes the last element off the end of an array and returns that element. (pops off the end)
              <br /><br />
              
              <span class="inline-code">push()</span> - adds specified element(s) to the <strong>end</strong> of an array; returns new array length. (pushes into the end)<br /><br />
              
              
              *<span class="inline-code">reduce()</span> - reduces given array to a single value; it executes a provided function for each value of the array, from left to right. <br />
              The return of that function is stored in an <strong>accumulator</strong>. Ex.:
              <code>
              var numbers = [65, 44, 12, 4];
              
              function getSum(total, num) {
                return total + num;
              }
              
              function myFunction(item) {
                numbers.reduce(getSum);
              }
              </code><br />
              
              <span class="inline-code">reduceRight()</span> - same as reduce() but operates right-to-left on an array instead of left-to-right.<br /><br />
              
              
              <span class="inline-code">reverse()</span> - reverses order of items in an array.<br /><br />
              
              
              <span class="inline-code">shift()</span> - removes the first item off the beginning of an array (shifts array "backward" - removes first item)<br /><br />
              
              
              <span class="inline-code">slice()</span> - returns selected elements of an array <strong>as a new array object</strong>. Syntax: <span class="inline-code">array.slice(start, end)</span>. slice() does not include the last given element.<br /><br />
              
              
              <span class="inline-code">some()</span> - checks if any elements in an array pass a test, provided as a function - returns a boolean. Ex.:
              <code>
              var ages = [3, 10, 18, 20];
              
              function checkAdult(age){
                return age >= 18;
              }
              
              function myFunction(){
                ages.some(checkAdult);
              }
              </code><br />
              
              <span class="inline-code">sort()</span> - sorts items of an array - can be alphabetic, numeric, ascending (up) or sescending (down). <br />
              By default, sort() sorts the values <strong>as strings</strong> in alphabetical, ascending order.
              <br />
              The sort() method provides incorrect results when sorting numbers if doing so by default - so provide a <strong>compare function</strong>. Ex.:
              <code>
              var points = [40, 100, 1, 5, 25, 10];
              points.sort(function(a, b){return a-b}); //compare function used with sort - ascending order
              
              points.sort(function(a, b){return b-a}); //descending order
              </code><br />
              
              <span class="inline-code">splice()</span> - adds or removes items to or from an array.<br /><br />
              Removing elements - give the <strong>index</strong> parameter, and <strong>number of elements to be removed</strong>: <span class="inline-code">array.splice(index, number of elements);</span> <br />
              If no second parameter is given, every element starting from the given index (as parameter a) will be removed from the array.
              <br /><br />
              Adding elements - these are specified as the 3rd, 4th, and 5th parameter (depending on how many are being added): <span class="inline-code">array.splice(index, number of elements, element, element…);</span> 
              Example that adds a and be to the beginning of an array while removing nothing:
              <code>
              array.splice(0, 0, 'a', 'b');
              </code><br />
              
              *Adding elements with splice() requires extra parameters/syntax.
              <br /><br />
              <span class="inline-code">toString()</span> - converts array to a string.
              <br /><br />
              
              <span class="inline-code">unshift()</span> - <strong>adds</strong> new items to the <strong>beginning</strong> of an array; returns new length (so shift "shifts front of array" after removing first element, this "unshifts" it by adding one instead).
              
              <span class="inline-code">valueOf()</span> - returns an array (a.k.a. the value of the array). Ex.:
              <code>
              var a = [1, 2, 3, 4];
              if (valueOf(a) != 1, 2, 3, 4) {
                //run something
              }
              </code><br />
            
            <h3>Array Properties</h3>            
              <span class="inline-code">constructor</span> - returns an array's constructor function.
              <br /><br />              
              <span class="inline-code">length</span> - sets or returns the number of elements in an array.
              <br /><br />              
              <span class="inline-code">prototype</span> - constructor that that allows you to <strong>add new properties and methods</strong> to the Array() object. <br />
              So, when constructing a property, <strong>ALL arrays are given the property</strong>, and its value, as default. <br />
              When constructing a method, ALL arrays have this method available. <br />
              *So Array.prototype doesn't refer to a single array but <strong>to the Array() object itself</strong>.
          
            
            <h2 id="esParam">Default Parameters</h2>            
            <h3>Parameter Defaults</h3>
              <br />
              *If a function is called with <strong>missing arguments</strong> (less than declared), the missing values are set to <strong>undefined</strong>. <br />
              Sometimes this is acceptable, but sometimes it's better to <strong>assign a default value to the parameter</strong>:
              <code>
              const myFunction = (x, y) => {
                if (y === undefined) {
                y=0;
                }
              };	//x is not called but is defined for clarity's sake
              </code>
            
            <h3>JS Parameter rules</h3>
              <br />
              *Javascript function definitions do not specify <strong>data types</strong> for parameters. <br />
              *Javascript functions do not perform <strong>type checking</strong> on the passed arguments. <br />
              *Javascript functions do not check the number of arguments received.
              
            <h2 id="esFor">for…of Loop</h2>
              
              <span class="inline-code">for…of</span> iterates through a list of elements, like an array, and <strong>returns the elements</strong> (not their indexes) one by one. Ex.:
              <code>
              let arr = [2, 3, 4, 1];
              for (let value of arr) {
                console.log(value);
              }
              
              //Output:
              //2
              //3
              //4
              //1
              </code>
            
            <h2 id="esSpread">Spread Attributes</h2>
              Introduced in ES6, <span class="inline-code">spread</span> allows an <strong>iterable</strong> (i.e. something that can be iterated over) to "spread" or expand, individually, inside a <strong>receiver</strong>. <br />
              <br />
              
              The <span class="inline-code">spread operator […]</span> is used to "spread" something, like a string stored in a variable being called using that operator, ex.: <span class="inline-code">[…codeburst] //codeburst is a string stored in a var, and contains 'CODEBURST'</span> .
              
              An example is <strong>
              using an array with 3 indexes to "spread" into a function that takes 3 arguments.</strong> <br /><br />
              
              An <strong>iterable</strong> can be a string, an array, a set, or anything that can be looped over. Ex.:
              
              <code>
              var phrase = 'PHRASE';
              var characters = [ …phrase ]; //spreading the string 'PHRASE'
              // [ 'P', 'H', 'R', 'A', 'S', 'E']
              </code>
              <br />
              *Spread (ES6) is more or less interchangeable with the apply method. <br />
              *Spread can also remove a key from an object without mutation.
              
            <h2 id="esMaps">Maps</h2>
            
              <strong>Maps</strong> are different from the <span class="inline-code">map()</span> method. Maps hold <strong>key-value pairs</strong>. They're similar to an array, but you can define your own indexes; indexes are also unique in maps. Ex.:
              <code>
              var NewMap = new Map() //insantiates a new Map() object, NOT calling the map() method
              NewMap.set('name', 'Sam');
              NewMap.set('id', '234935');
              NewMap.set('interest', ['javascript', 'node']);
              
              NewMap.get('name'); //Sam
              NewMap.get('id'); //234935
              NewMap.get('interest'); /['javascript', 'node']
              </code>
              
            
            <h2 id="esSets">Sets</h2>
              
              <strong>Sets</strong> - are very simple - they're used to store the unique values of any type. A <strong>set</strong> is a collection of items which are <strong>unique</strong>, i.e. no element can be repeated. <br />
              Syntax:
              <code>
              set1.add(val);
              
              //Parameter:
              //val - value to be added to set
              
              //Returns:
              the set object
              </code>
              <br />
              Example:
              <code>
              var set1 = new Set(); //create a new empty set
              
              set1.add(10);
              set1.add(20);
              </code>
            
            <h2 id="esStatic">Static Methods</h2>
              <strong>Static methods</strong> - intended to provide <strong>class-specific</strong> methods for OOP in Javascript. <br />
              Static methods are similar to class methods in Ruby. <br />
              To declare a static methods, prefix a <strong>method declaration</strong> with the word <strong>static</strong> inside the <strong>class declaration</strong>, ex.:
              <code>
              class myClass(){
                static methodName(){
                  console.log("something");
                }
              }
              </code>
              
              Static methods are often used to create <strong>utility functions</strong> for an application.
            
            <h2 id="esGetSet">Getters and Setters</h2>            
            <h3>Basics</h3>
              <strong>Getters and setters</strong> are useful if you use JS classes. They're <strong>accessor properties</strong>, represented as "getter" and "setter" methods, and are denoted by <span class="inline-code">get</span> and <span class="inline-code">set</span>.  <br /><br />
              The getter works when <span class="inline-code">obj.propName</span> is <strong>read</strong>; the setter works when <span class="inline-code">obj.propName</span> is being <strong>defined</strong>. <br /><br />
              
              Accessor properties <strong>are only accessible with get/set</strong>. <br />
              A property can either be a <strong>data property</strong> or an <strong>accessor property</strong>, but not both. <br /><br />
            
            <h3>Get</h3>
              
              <span class="inline-code">get</span> - a function without arguments; works when a property is <strong>read</strong>.
              
              Get example:
              <code>
              let user = {
                name: "John",
                surname: "Smith",
              
                get fullName() { //notice that get has no argument
                  return '${this.name} ${this.surname}';
                }
              };
              </code>
            
            <h3>Set</h3>
            
              <span class="inline-code">set</span> - a function with <strong>one</strong> argument; called when the property is being set. Ex.:
              
              <code>
              let user = {
                name: "John",
                surname: "Smith".
              
                set fullName(value){ //notice that set has one argument being set
                  [this.name, this.surname] = value.split(" ");
                }
              };
              </code>
              
              <h2 id="esDestruc">Destructuring</h2>

                The <strong>destructuring assignment</strong> syntax is a Javascript <strong>expression</strong> that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.
                <br /><br />
                Basic assignment example:
                <code>
                var o = {p: 42, q: true};
                var {p, q} = o;
                //this destructures an object
                </code>
            
            <h2 id="esPromise">Promises</h2>
              
              <strong>Promises</strong> either succeed or fail, once.
              <br /><br />
              Have a state of either <span class="inline-code">fulfilled</span>, <span class="inline-code">rejected</span>, <span class="inline-code">pending</span> 
              or <span class="inline-code">settled</span>.
              newline
              
              Example of a promise that <strong>resolves immediately</strong>:
              <code>
              var p1 = Promise.resolve("Resolve Me")
              
              p1.then
              
              //then is a function that takes two optional arguments, being first a. a callback for success, and b. another for failure * these are optional
              </code>
              
            <h3>Terms</h3>
              
              .then <br />
              (res) <br />
              Promise.resolve <br />
              Promises guide <br />
                  
            super - keyword used to access and call functions on an argument's parent. <br />
            Ex. super([something]); //calls parent constructor <br /><br />
              
            progressive web apps - designed to deliver an experience similar to native apps. One of the most significant abilities for this to occur is for the "app" to function when offline, which can be accomplished using service workers. <br /><br />

            progressive web apps &lt;-&gt; service workers












            </article>
            </section>

          <section class="main-section" id="jQuery">
            <header>jQuery</header>
            <article> 
                <h2>jQuery Method Examples:</h2>
                <li>.addClass()</li>
                <li>.removeClass()</li>
                <li>.ready (i.e.docready)</li>
                <li>.css()</li>
                <li>.prop() - allows you to adjust the properties of elements.</li>
                <li>.html() - lets you add HTML tags and text within an element. Any content previously within the element will be completely replaced with the content you provide using this function.</li>
                <li>.remove()</li>
                <li>appendTo() - allows you to select html elements and append them to other elements, ex:</li>
                
                <code>
                $("#target4").appendTo("#right-well")
                </code>
                
                <li>clone() - makes a copy of an element,ex.:</li>
                <code>
                $("#target5").clone().appendTo("#left-well");
                </code>
                <li>children() - Allows you to access the children of whichever element you've selected.</li>
                <li>parent() that allows you to access the parent of whichever element you've selected. Ex: </li>
                <code>
                $("#target1").parent().css("background-color", "red");  
                </code>
                
                Methods can be nested one in another this way to perform multiple actions in order.                    
                
                <h2>Targeting With jQuery</h2>
                
                When we start using jQuery, we will modify HTML elements without needing to actually change them in HTML, ex: <br />
              
                
                <code>
              
                  $(document).ready(function() {
                    $("button").addClass("animated bounce");
                  });
              
                </code>
                <p>
                This makes all button elements bounce. They're selected with $("button"), then we added some CSS classes to them with .addClass("animated bounce");
                </p>
                There are three ways of targeting elements: 
                <li>by type: $("button")</li>
                <li>by class: $(".btn")</li>
                <li>by id $("#target1").</li>
                
               
                
                <h2>Target the Parent of an Element Using jQuery</h2>
                
                For example, your jQuery Playground h3 element has the parent element of <div class="container-fluid">, which itself has the parent body.
                
                jQuery has a function called parent() that allows you to access the parent of whichever element you've selected.
                
                Here's an example of how you would use the parent() function if you wanted to give the parent element of the left-well element a background color of blue:
                <code>
                $("#left-well").parent().css("background-color", "blue")
                </code>
                
                <h2>Target a Specific Child of an Element Using jQuery</h2>
                
                <p>jQuery uses CSS Selectors to target elements. target:nth-child(n) css selector allows you to select all the nth elements with the target class or element type.</p>
                
                Ex. Give the third element in each well the bounce class:
                <code>
                $(".target:nth-child(3)").addClass("animated bounce");
                </code>
              </article>
            
            </section>

          <section class="main-section" id="OOP">
            <header>OOP</header>
            <article>

            <h2>OOP is all about:</h2>
            <li>An Object</li> 
            <li>Its Properties (Ex. State)</li> 
            <li>Its Methods (Ex. Sort)</li> 

            <p>Code is organized into objects.
              You can use dot OR bracket notation to access the properties of an object. <br />
              A JavaScript object is, in that sense, a collection of named properties and methods - a function. 
              An object can be stored in a variable, and the properties and methods accessed using the dot syntax.
            </p>

            <h2>Object literal syntax:</h2>
            1. A colon separates a prop name from a val<br />
            2. A comma separates each name-val pair<br />
            3. There should be no comma after the last name-val pair<br /><br />

            Ex:
            <code>
            var myObject = {
              tempProp: 'some string value',
              assPropr: 2,
              boolProp: true
            }; 
            </code>



            <h2>Objects and Operations</h2>

            Types of operations you can perform on an object:
            
            [table]
            Creation - Creating a new object.
            Addition - Adding properties to an object.
            Reading/Retrieving - Reading the <strong>value</strong> associated with a <strong>key</strong>.
            Existence - Whether a property exists in an object.
            Updation - Updating the values of existing properties.
            Deletion - Deleting existing properties.
            Iteration (Enumeration) - Looping over an object's <strong>keys and values</strong>.
            Comparison - Comparing two different objects.
            Copying - Making a copy of an existing object.
            
            <h3>Creation</h3>
            
            Properties of an object <strong>are just like variables</strong>.





            <h2>Class vs Object:</h2>

            <p><strong>Class > Object</strong></p>
        
            <p><strong>Class </strong>- A program-code-template for creating OBJECTS. <br /><br />
            A class provides: <br /></p>
            <li>Initial VALS for the STATE(member variables)</li>
            <li>Implementations of behavior (member functions/methods)</li>
            <p>
            When an object is created using a constructor, the resulting object is called an instance of the class.
            So when you use a class as a kind of object builder, and make some objects, those new objects created from the class are called instances.</p>
              <p>
            <strong>Classical</strong> = class-based = defining CLASSES of OBJECTS, as opposed to the OBJECTS THEMSELVES.<br />
            This does contrast with prototypal because in prototypal, <strong>an object's prototype it's created from is itself an object and not a class.</strong><br /><br />
            The structure and behavior of an object in class-based is defined by the class, read blueprint, of all objects of a specific type (aka class).</p>
            

            <h2>Terms</h2>

            Prototype = spawns objects <br />
            Imperative - Allows side effects<br />
            OO - Groups code together with the state the code modifies<br />
            Procedural - Groups code into functions<br />
            Declarative - does not state order in which operations execute<br />
            Functional - disallows side effects<br />
            Event-loop programming<br />

            method pointers<br />
            member access control<br />
            implicit data member<br />
            class hierarchy<br />
            OLOO - objects linking to other objects - prototypal<br />

            Class-based model<br />
            Object-based model<br />

            Object Composition vs Class Inheritance<br />

            Strict mode - Just like a weakly typed language becomes more strongly typed<br />
            Silent JS errors will be changed to throw errors.<br />

            Object literal - <br />
            A comma-separated list of name value pairs - encapsulates data - minimizes use of global variables.
            <br /><br />
            
            </article>
            </section>

          <section class="main-section" id="Libraries">
            <header>JS Libraries</header>        
            <article> 
              <h3>async</h3>
              <h3>babel</h3>
              <h3>backbone</h3>
              <h3>body-parser</h3>
              <h3>browserify</h3>
              <h3>Commonjs</h3>
              <p>module.exports</p>
              <h3>d3</h3>
              <h3>express</h3>
              <h3>gulp</h3>
              <h3>live-server</h3>
              <h3>lodash</h3>

                <strong>Lodash</strong> - provides a massive library of "utility" functions (like loop for N times), using <strong>functional programming</strong>. <br /><br />

                It's largely based off Underscore.js, including syntax (_.method). (Low-dash)
                <br /><br />

                Ex.:
                <code>
                // Fetch the name of the first pet from each owner
                var ownerArr = [{
                "owner": "Colin",
                "pets": [{"name":"dog1"}, {"name": "dog2"}]
                }, {
                "owner": "John",
                "pets": [{"name":"dog3"}, {"name": "dog4"}]
                }];

                // Array's map method.
                ownerArr.map(function(owner){
                return owner.pets[0].name;
                });

                // Lodash
                _.map(ownerArr, 'pets[0].name');
                </code>

                Lodash <strong>map</strong> method - works exactly like the JS map method, but it's able to navigate deeply-nested properties by simply providing a string instead of a callback function. <br /><br />

                <a href="https://lodash.com/docs/4.17.11" target="_blank" rel="noopener noreferrer">Lodash Documentation</a> <br /><br />
                 
                <a href="https://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting" target="_blank" rel="noopener noreferrer">Lodash Basics    </a>

                <h3>Modernizr</h3>
                Modernizr - about standardized feature detection. lets you detect HTML5/CSS3 features, and lets JS avoid using unimplemented features, or use a workaround to emulate them. 



              <h3>moment-js</h3>
              <h3>particles-js</h3>
              <h3>react</h3>
              <h3>react-dom</h3>
              <h3>socket.io</h3>
              <h3>three.js</h3>
              <h3>vue</h3>
                <p>          
                <li>designed to be more of a complete package</li>
                <li>considered easier for beginners than react/li>
                <li>react has a larger user base and job opportunities</li>
                </p>
              <h3>Webpack</h3>        
                <strong>code splitting</strong> - don't load code that you don't need to. helps reduce js payloads. <br /><br />

                <strong>lazy loading</strong> - "on-demand" loading - involves splitting code at logical breakpoints, then loading it once the user has done something that requires or will require a new block of code. <br />
                
                This speeds up the initial load of the app, and lightens its overall weight as some blocks might never be loaded. <br /><br />
                
                Webpack converts dynamic code and modules into static assets. <br /><br />
                
                So it takes modules, which can be custom or downloaded from npm, and generates static assets to represent those modules. <br /><br />
                
                You can take a fully dynamic application and package it into static files to deploy to the server. You can also extend webpack with plugins and loaders.
                
                <strong>modules</strong> - abstraction, encapsulation, usually delegates functions to libraries so we don't really have to understand them. ><<<<<<<<<<<<<
                <br /><br />
                
                So abstraction is about *not* knowing the ins and outs of something or having to - just a. requiring it and b. being able to use the public API that's exposed.
                <br /><br />
                
                <strong>loaders</strong> - can be used to transform other resources into js (so a loader is the same thing as a transpiler essentially),
                
                
                <strong>clever parsing</strong> - require("./templates/" + name + ".jade") - in Webpack, this allows you to parse essentially any third-party library.
                <br /><br />
                
                So something like app.bundle.js (where the code's all crazy af and looks minified) is all the modules bundled into one file from the entry point AND its dependencies.
                


            </article>
            </section>      
            
            <section class="main-section" id="React">
                <header>React</header>
                <article> 

                <h2>Basics</h2>

                  React in itself has a very small API, and you basically need to understand 4 concepts to get started: <br />
                  Components <br />
                  JSX <br />
                  State <br />
                  Props <br />

                <h3>module.exports</h3>
                  Example:
                  <code>
                    module.exports = {
                      entry: '.src/index.js',   //specify react entry file
                      output:{
                          path: path.join(__dirname, '/dist'),
                          filename: 'index_bundle.js'
                      },
                      module: {
                          rules: [
                              {
                                  test: /\.js$/,
                                  exclude: /node_modules/,    
                                  use: {
                                      loader: 'babel-loader'
                                  }
                              }
                          ]
                      }
                    }
                  </code>
                <h3>Tips</h3>               
                  
                  *React is best for large programs that display a lot of changing data. <br />
                  *If a JS file containes JSX then it will have to be compiled. <br />
                
                <h3>Redux</h3>            
                <h4>Actions</h4>
                  
                  <strong>Actions</strong> are <strong>payloads</strong> of information that send data from your application to your <strong>store</strong>.
                  <br /><br />
                  Actions are the only source of information for the store. You send actions to the store using <span class="inline-code">store.dispatch()</span>. <br />
                  
                  Example of an action that represents adding a new todo item:
                  
                  <code>
                  const ADD_TODO = 'ADD_TODO'	//type defined as string constant
                  
                  {
                    type: ADD_TODO,
                    text: 'Build my first Redux app'
                  
                  }
                  </code>
                  
                  <strong>Actions</strong> are plain JS objects. They must have a <span class="inline-code">type</span> property that indicates the type of action being performed (ADD_TODO in the above example). 
                  <br /><br />
                  The only way to change the state (which is read-only) is to emit an action, which is an object describing what happened.
                  <br /><br />
                  
                  <strong>Store</strong> - an object that brings actions and reducers together.
                  
                  The state of your whole application is stored in an <strong>object tree</strong>, within a single store. So, the store is a single state tree.
                  
                <h4>State</h4>
                  In React, you can imagine the app's state being described as a plain JS obeject. For example, the state of a todo app might look like this:
                  
                  <code>
                  {
                    todos: [{
                      text: 'Eat food',
                      completed: false
                    }, {
                      text: 'Exercise',
                      completed: true
                    }],
                    visibilityFilter: 'SHOW_COMPLETED'
                  }
                  </code>
                  
                  This object is like a "model", except there are no setters. This is so <strong>different parts of the code can't change the state arbitrarily, which can lead to hard-to-reproduce bugs.</strong>
                  <br /><br />
                  To change something in the state you need to dispatch an <strong>action</strong>, which is a <strong>plain Javascript object</strong> that describes what happened. <br />
                  Action examples:
                  
                  <code>
                  { type: 'ADD_TODO', text: 'Go to swimming pool' }
                  { type: 'TOGGLE_TODO', index: 1 }
                  { type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL'}
                  </code>
                  
                  Enforcing that <strong>every change is described as an action</strong> lets you have a clear understanding of what's going on in the app. So if something changes, you know why. Actions are simply like breadcrumbs of what's happened.
                  
                  <br /><br />
                  
                  To <strong>tie state and actions together</strong>, you write a function called a reducer. A reducer is just a function that a.<strong>takes state and action as arguments</strong>, and b.<strong>returns the next state of the app</strong>.
                  <br /><br />
                  It would be hard to write such a function for a larger app, so you write smaller functions managing <strong>parts</strong> of the state.
                  
                <h4>Reducers</h4>
                  
                  In Redux, state is managed by <strong>reducer</strong> functions. In functional programming, reducers like Array.reduce(), for example, <strong>take a collection of inputs and reduce them to a single value</strong>. That single output could be any type. You could count inputs and return a total as an integer.
                  <br /><br />
                  
                  Reducers are just <strong>pure functions that take the previous state of an action and return the next state</strong>. Return new state objects, instead of mutating the previous state.
                  
                  A Redux reducer <strong>takes the current state, and returns the new state</strong>. Because React only re-renders if the object it's given has changed we almost always want to <strong>return a new object</strong> in the Reducer.
                  <br /><br />
                  You can use one reducer for a collection of data, and specify specific actions for a reduce to act on. In Redux these are called <strong>Actions</strong>, while in Vuex they're called <strong>Mutations</strong>. So, 1. <strong>actions mutate state</strong> as they're sent into Redux, 2. which <strong>maps them to the right reducer</strong> and 3. <strong>applies middlewares</strong>.
                  <br /><br />
                  Reducer functions in Redux typically <strong>take an object as the second argument</strong>, which is the action, and <strong>use a switch control structure</strong> on <span class="inline-code">action.type</span>. Example:
                  
                  <code>
                  import {ADD_PROCESSOR} from './actions';
                  
                  /**
                  Reducer for managing a collection of processors
                  State is the collection of processors as a map
                  
                  export const processorsReducer = (state = {})              
                  </code>

                  <h3>create-react-app</h3>

                    Adds: <br />
                    <span class="inline-code">npm run build </span>  <br />
                    <span class="inline-code">npm test </span> | run testing suite using jest  <br />
                    <span class="inline-code">npm eject </span>  <br />
                    

    
                </article>
                </section>               
            




            </article>
            </section>                    
  
          </main>
</body>

<!--
<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
-->
<script src="js/script.js"></script>

          <!--<section class="main-section" id="blank">
            <header>blank</header>
            <article> 
            </article>
            </section>                  
          -->

</html>